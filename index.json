[{"content":"以下是2025.11.20第一次搞得周报 C已完。C++已学完STL容器和算法（和一些好玩的特性）。 数据结构在学STL都涉及了，纯学数据结构的话停留在串。 运维相关内容多且杂，具体内容见组会报告。\n之后有点东西都可以从这写着，刚做草稿： 比如今天，2025.11.23开始使用CLion来做Qt的程序。 而且，给网站上搞了一个昼夜切换的无敌按键（hhhh）。 还有猫猫砸钢琴音乐播放器！！！ 和闪光miku！\n","permalink":"https://QwQBiG.github.io/posts/zhouji/","summary":"\u003ch2 id=\"以下是20251120第一次搞得周报\"\u003e以下是2025.11.20第一次搞得周报\u003c/h2\u003e\n\u003cp\u003eC已完。C++已学完STL容器和算法（和一些好玩的特性）。\n数据结构在学STL都涉及了，纯学数据结构的话停留在串。\n运维相关内容多且杂，具体内容见组会报告。\u003c/p\u003e\n\u003ch3 id=\"之后有点东西都可以从这写着刚做草稿\"\u003e之后有点东西都可以从这写着，刚做草稿：\u003c/h3\u003e\n\u003cp\u003e比如今天，2025.11.23开始使用CLion来做Qt的程序。\n而且，给网站上搞了一个昼夜切换的无敌按键（hhhh）。\n还有猫猫砸钢琴音乐播放器！！！\n和闪光miku！\u003c/p\u003e","title":"我の周报"},{"content":"容器就是数据结构啦~\n","permalink":"https://QwQBiG.github.io/posts/stlcontainer/","summary":"\u003cp\u003e容器就是数据结构啦~\u003c/p\u003e","title":"STL 容器"},{"content":"算法最爽了~\n","permalink":"https://QwQBiG.github.io/posts/stlalgorithm/","summary":"\u003cp\u003e算法最爽了~\u003c/p\u003e","title":"STL 算法"},{"content":"Kubernetes 学习笔记 核心思想篇：两大基石 1. 为何选择 Kubernetes？ 单个 Docker 容器是孤立的。当容器数量增多，我们会面临一系列棘手的问题：\n故障恢复：一个容器挂了怎么办？ 服务发现：容器 B 如何找到容器 A 的 IP 地址？ 负载均衡：如何将流量平均分配给多个相同的容器？ 扩缩容：如何根据负载自动增加或减少容器数量？ Kubernetes (K8s) 就是一个容器编排平台，它以标准化的方式完美地解决了以上所有问题。\n2. 命令式 vs. 声明式 (核心思想转变) 命令式 (Imperative)：你一步步告诉 K8s “做什么” (kubectl create, kubectl scale)。这就像手动驾驶，直观但难以追踪和重复。 声明式 (Declarative)：你向 K8s 提交一个 YAML 文件，告诉它你**“想要什么状态”**。这就像设定导航目的地，K8s 会自己想办法开车到达，并且如果偏离了航线（比如有 Pod 挂了），它会自动修正。这是 K8s 的精髓，也是现代化的管理方式。 环境搭建篇：Kind (Kubernetes in Docker) 在复杂的网络环境下，使用 Kind 搭建本地集群是最可靠、轻量且快速的方式。\n1. 安装核心工具 安装 kubectl (K8s 命令行客户端)\n1 2 # (根据官方文档，使用 apt 或其他包管理器安装) sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install -y kubectl 安装 Go 语言环境 (用于安装 Kind)\n1 sudo apt-get install golang-go -y 设置 Go 国内代理并安装 kind\n这是解决网络问题的关键，goproxy.cn 会加速模块下载。\n1 2 3 export GOPROXY=https://goproxy.cn,direct go install sigs.k8s.io/kind@v0.22.0 sudo mv ~/go/bin/kind /usr/local/bin/ 验证安装\n1 2 kubectl version --client kind version 2. 编写 Kind 集群配置文件 这份文件解决了两个关键问题：① K8s 核心组件镜像的拉取问题；② 虚拟机端口冲突问题。\n创建 kind-config.yaml 文件： 1 nano kind-config.yaml 粘贴以下内容： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 kind: Cluster apiVersion: kind.x-k8s.io/v1alpha4 # 解决 K8s 核心组件镜像拉取问题 kubeadmConfigPatches: - | apiVersion: kubeadm.k8s.io/v1beta3 kind: ClusterConfiguration imageRepository: registry.aliyuncs.com/google_containers nodes: - role: control-plane kubeadmConfigPatches: - | kind: InitConfiguration nodeRegistration: kubeletExtraArgs: node-labels: \u0026#34;ingress-ready=true\u0026#34; # 解决宿主机端口占用问题，将 80/443 映射到高位端口 extraPortMappings: - containerPort: 80 hostPort: 52014 protocol: TCP - containerPort: 443 hostPort: 52015 protocol: TCP 3. 启动与销毁集群 启动集群 1 kind create cluster --config=kind-config.yaml 验证集群就绪 1 2 kubectl get nodes # 预期输出一个名为 kind-control-plane 的节点，状态为 Ready 销毁集群 (学习结束时) 1 kind delete cluster YAML 核心篇：Pod 的“蓝图” 1. YAML 四段式结构 apiVersion: API 版本，如 v1 kind: 资源类型，如 Pod metadata: 元数据，包括 name, namespace, labels spec: 期望状态，定义了资源的核心属性 2. 单容器 Pod 示例 1 2 3 4 5 6 7 8 9 10 apiVersion: v1 kind: Pod metadata: name: my-nginx-pod spec: containers: - name: nginx-container image: nginx:1.22 ports: - containerPort: 80 3. 多容器 Pod (Sidecar 模式) 与数据共享 通过 volumes 和 volumeMounts 实现一个 Pod 内多个容器间的文件共享。\nspec.volumes: 在 Pod 层面定义一个共享存储卷（“储藏室”）。 spec.containers[].volumeMounts: 在容器层面将共享卷挂载到容器内的特定路径（“开一扇门到储藏室”）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 apiVersion: v1 kind: Pod metadata: name: multi-container-demo spec: # 1. 定义一个名为 \u0026#34;shared-html\u0026#34; 的共享卷 volumes: - name: shared-html emptyDir: {} containers: # 容器一：Nginx - name: nginx-container image: nginx:1.22 # 2. 将共享卷挂载到 Nginx 的网站根目录 volumeMounts: - name: shared-html mountPath: /usr/share/nginx/html # 容器二：Busybox (Sidecar) - name: sidecar-container image: busybox:1.35 command: [\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;while true; do date \u0026gt;\u0026gt; /var/log/index.html; sleep 5; done\u0026#34;] # 3. 将同一个共享卷挂载到 Busybox 的日志目录 volumeMounts: - name: shared-html mountPath: /var/log 日常操作与调试篇 (kubectl) 1. 核心管理命令 应用配置: kubectl apply -f [文件名.yaml] 删除资源: kubectl delete -f [文件名.yaml] 或 kubectl delete pod [pod名] 2. 状态检查“三板斧” kubectl get : 快速查看资源列表和状态。 kubectl get pods: 查看当前命名空间的 Pod。 kubectl get pods -n \u0026lt;命名空间\u0026gt;: 查看指定命名空间的 Pod。 kubectl get pods -A: 查看所有命名空间的 Pod。 kubectl get pods -o wide: 查看更多信息（IP, 所在节点）。 kubectl describe : 查看资源的详细信息和事件日志。 kubectl describe pod \u0026lt;pod名\u0026gt; 排错关键：永远第一时间查看最下方的 Events 部分，它记录了 Pod 创建过程中的所有成功和失败信息。\nkubectl logs : 查看容器内部的标准输出日志。 kubectl logs \u0026lt;pod名\u0026gt; kubectl logs \u0026lt;pod名\u0026gt; -c \u0026lt;容器名\u0026gt;: 查看多容器 Pod 中特定容器的日志。 kubectl logs \u0026lt;pod名\u0026gt; --previous: 查看上一次崩溃退出的容器的日志。 3. 交互命令 kubectl exec : 进入一个正在运行的容器内部。 1 kubectl exec -it \u0026lt;pod名\u0026gt; -c \u0026lt;容器名\u0026gt; -- /bin/bash 4. 资源组织 Namespace (文件夹): 用于逻辑隔离。\n创建: kubectl create namespace \u0026lt;命名空间名\u0026gt; 删除: kubectl delete namespace \u0026lt;命名空间名\u0026gt; (会删除其内部所有资源) Labels \u0026amp; Selectors (标签与筛选器): 用于对资源进行分组和筛选。\n在 metadata.labels 中定义键值对。 使用 -l 参数进行筛选: kubectl get pods -l app=my-app,env=prod 实战排错篇：网络问题终极方案 问题现象: ImagePullBackOff / ErrImagePull Pod 状态显示拉取镜像失败，describe 事件中提示 i/o timeout 或 not found。\n方案一：(推荐) 修改 YAML，使用国内镜像源 直接在 YAML 的 image 字段中使用国内的、可访问的镜像地址。\n1 2 3 4 5 6 spec: containers: - name: redis-container # 原镜像: image: redis:7.0 # 修改后: image: m.daocloud.io/docker.io/library/redis:7.0 方案二：(极端网络环境) 本地加载 当所有镜像源都无法从 Kind 节点内部访问时，采用“主机下载，加载进集群”的策略。\n在主机 (Ubuntu VM) 上拉取镜像\n1 docker pull m.daocloud.io/docker.io/library/redis:7.0 为镜像打上官方标签 (关键)\nK8s Pod 的 YAML 里使用的是官方短名称，所以必须打这个标签。\n1 docker tag m.daocloud.io/docker.io/library/redis:7.0 redis:7.0 将打好标签的镜像加载进 Kind 集群\n1 kind load docker-image redis:7.0 最后，使用包含官方短名称 (image: redis:7.0) 的 YAML 文件进行部署。 K8s 会直接使用节点上的本地镜像，不再进行网络拉取。\n","permalink":"https://QwQBiG.github.io/posts/yunwei/","summary":"\u003ch1 id=\"kubernetes-学习笔记\"\u003eKubernetes 学习笔记\u003c/h1\u003e\n\u003ch2 id=\"核心思想篇两大基石\"\u003e核心思想篇：两大基石\u003c/h2\u003e\n\u003ch3 id=\"1-为何选择-kubernetes\"\u003e1. 为何选择 Kubernetes？\u003c/h3\u003e\n\u003cp\u003e单个 Docker 容器是孤立的。当容器数量增多，我们会面临一系列棘手的问题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e故障恢复\u003c/strong\u003e：一个容器挂了怎么办？\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e服务发现\u003c/strong\u003e：容器 B 如何找到容器 A 的 IP 地址？\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e负载均衡\u003c/strong\u003e：如何将流量平均分配给多个相同的容器？\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e扩缩容\u003c/strong\u003e：如何根据负载自动增加或减少容器数量？\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eKubernetes (K8s) 就是一个\u003cstrong\u003e容器编排平台\u003c/strong\u003e，它以标准化的方式完美地解决了以上所有问题。\u003c/p\u003e\n\u003ch3 id=\"2-命令式-vs-声明式-核心思想转变\"\u003e2. 命令式 vs. 声明式 (核心思想转变)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e命令式 (Imperative)\u003c/strong\u003e：你一步步告诉 K8s \u003cstrong\u003e“做什么”\u003c/strong\u003e (\u003ccode\u003ekubectl create\u003c/code\u003e, \u003ccode\u003ekubectl scale\u003c/code\u003e)。这就像手动驾驶，直观但难以追踪和重复。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e声明式 (Declarative)\u003c/strong\u003e：你向 K8s 提交一个 YAML 文件，告诉它你**“想要什么状态”**。这就像设定导航目的地，K8s 会自己想办法开车到达，并且如果偏离了航线（比如有 Pod 挂了），它会自动修正。\u003cstrong\u003e这是 K8s 的精髓，也是现代化的管理方式。\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"环境搭建篇kind-kubernetes-in-docker\"\u003e环境搭建篇：Kind (Kubernetes in Docker)\u003c/h2\u003e\n\u003cp\u003e在复杂的网络环境下，使用 Kind 搭建本地集群是最可靠、轻量且快速的方式。\u003c/p\u003e\n\u003ch3 id=\"1-安装核心工具\"\u003e1. 安装核心工具\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e安装 \u003ccode\u003ekubectl\u003c/code\u003e (K8s 命令行客户端)\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# (根据官方文档，使用 apt 或其他包管理器安装)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt-get update \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e sudo apt-get install -y kubectl\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e安装 Go 语言环境 (用于安装 Kind)\u003c/strong\u003e\u003c/p\u003e","title":"运维"},{"content":"组会报告 1 容我想想上几周我干了什么：\n首先在最开始，我搞了一个VMware开始玩弄Ubuntu，这个时候，我是在有这个项目通知之前，到货了一个鸿蒙系统的平板（书接上回），凭借“来都来了”与“捣鼓捣鼓”的心态，我开始安装搞termux和X11，想着搞个linux终端玩玩，但是因为鸿蒙，所以是无法启动的，但是我都看了好几个视频了，还是想试试linux，所以从电脑装了VMware，我这边是跟着千峰的（BV1VH1aBtEz2 ）视频来的，主要学的是虚拟机相关内容，同时包括一些Ubuntu命令：基础的ls,apt,tree,cd,pwd,cat,管道，重定向等，安装了插件：vmtools,samba,一些命令提示组件啥的（还有TheFuck，白月光），接触了主要是用SSH协议的Xshell远程终端（最后扔了）。算是对linux的Ubuntu发行版有了基础认识哈。（千峰的东西还是太过时了qwq）\n然后就是新机必做的美化，有道是：”用着爽不一定真爽，但看着爽一定是真爽。“终端是块黑黢黢的方块，字体是被压缩成俄式比例的，那确实很可怕了\u0026hellip;那时还没找毛学长，没搞zsh，终端还是bash，此时搞了个kitty图形化终端，以此来搞出来壁纸画面；之后开始使用oh my zsh和字体pl10k，搞出了jb momo（全拼一直忘）和代码高亮，和右键补全，这时的我受到豆沙包和臭鲸鱼的极致恶心，所幸镜像一天10次对话的ChatGPT还像是个人\u0026hellip;但是还是让我感觉出，整这种相对完整的内容，还是博客、论坛、b站（一般）啥的好一些，我的美化，是跟着收藏的一篇CSDN的文章搞得（安装oh-my-zsh，配置命令行高亮，命令提示，打造高效终端_oh my zsh-CSDN博客）。终于，也是有了一个好看些的Ubuntu。\n或许，我们感觉美化有点搞偏了，但是也可以学到pip,git一些下载、拉镜像源的方法，比如说找马云对吧（Gitee）。就像是孔老二说的可以“兴观群怨”的《诗经》，退一步说，这也算是一种识字教育，见识这些奇怪的“鸟兽草木之名”，也有帮助。\n之后，我深刻的了解到、并可以熟练进行Ubuntu的紧急操作界面的恢复\u0026hellip;因为可能是我把第二个开的虚拟机，放到了第一个虚拟机没有清理完全的文件夹，导致lvm卷他找不到，那两天左右，我大概有20次以上的重启到紧急模式到好了到测试的经历，可以说是十分熟练（酸爽）了。\n然后转折点：毛学长给我分了一块实验室服务器的Ubuntu，所以开始搞远程终端的美化：\n最终是扔了Xshell，用了开源的Tabby Terminal，如下图（还没整）哈，这么多好用的远程，难道主要是因为这个有壁纸插件吗？还真是。插件好啊，点下安装就让用。\n然后，在我回宿舍路上，想要点开终端fuck一下，猛然发现连接寄掉了，原因都知道，这是在实验室的内网，问学长让我瞅瞅内网穿透，我听着有点高级哈，”穿透“，像是网安的词。当我下载、点开樱花穿透后：发现，这不是我的世界联机用的吗hh。由此，以及后来用的panel.frplients，以及学长给到的http协议的代理，都是，额，应该是计算机网络都要学的内容，TCP/SSH/HTTP/HTTPS这些协议嗯。以及一点防火墙的设置，都有学到。\n在这些内容的中间，从linux(BV1cq421w72c )到docker（BV14s4y1i7Vf ）（BV1THKyzBER6 ）的基础视频，我是跟着敲了的。当然docker pull 不了镜像，问ai快给我俩问四了，发现是另有缘由是吧（当然有了代理，一路畅通）。\n看的相关的科普视频关于docker,k8s,k3s,docker compose,docker swarm\u0026hellip;比较杂\u0026hellip;\n然后就是调教ai（为了多玩玩docker），想搞个网站，一开始是吧，docker建了个文件夹搞点html,css做了个界面，发现内网\u0026hellip;然后拉了一个wordpress是个动态网站，依旧内网\u0026hellip;再看域名，看累了没搞，之后还想内网穿透，结果https\u0026hellip;相关视频看了大概，网络协议也是大概学到了一些\u0026hellip;\n最终是用的Github Pages静态网站，不用自己搞sql、redis啥的，也不用搞安全，还是很爽的，加上Github Action 发布文章只要win终端git push一下就好了。\n这边，主要是接触了git、前端代码、以及重要的shell内容。\nhttps://qwqbig.github.io/\n网址如上，里面有建站的全流程，想看的话。我应该有两天时间再干这个。\n最后这两天就感到有点子无聊了，回到了STL 和 C++11以上的好的特性上去玩。\n那我正好鼓捣k8s玩了，还以为要再docker几天的。\n对了，我学过py（第一个学的就是py），脚本方面的接触在网站上建站过程中提及到了也。\n本来我都想开始把原来做的题用cpp重写的，像是把这个世界用Rust重写一遍似的\u0026hellip;(话说蟹教有干翻C++的未来吗，不清楚)。\n写日记挺好玩的，我要同步到https://qwqbig.github.io/上hhh\n欧克，完事了，bye~\n组会报告 2 总结：本周主要搞了 K8s 本地环境的网络与镜像难题，完成了从 kubectl 命令式操作到 YAML 声明式管理的思维转变，掌握了 Pod 高级模式（Sidecar）、资源隔离（Namespace/Labels）及标准排错流程。\n主要是 K8s 本地环境搭建与 Pod 编排\n1. 可恶的网：Kind + 国内源\n由于 Minikube 网络受限，转用 Kind (Kubernetes in Docker)。通过配置 GOPROXY 完成源码编译安装，配合 kind-config.yaml 定制国内镜像源及端口映射，解决了环境初始化问题。\n（Kind 把 Docker 容器当成 K8s 的节点（Node）来跑）\n2. 核心概念：从命令式到声明式\n基础：熟悉 kubectl 动词语法，并且迅速从命令式（CLI）转向声明式（YAML），主要是有版本控制这些好处。\nPod 深度理解：通过实操 边车（Sidecar） 模式（Nginx + Busybox 共享存储），深刻理解 Pod 作为“最小原子单元”的共享网络与存储特性。\n3. 运维与排错方法\n镜像策略：面对 ImagePullBackOff，除了替换国内源（如 m.daocloud.io），还掌握了 docker pull + kind load 的离线镜像预加载手段。（就是有点大）\nDebug 流程：建立了标准排错链：若是资源调度问题（如 Crash/PullErr）用 kubectl describe 看 Events，应用内部报错查 kubectl logs。\n4. 搞一搞\n隔离：掌握 Namespace 进行环境隔离，利用 Labels/Selectors 实现资源的灵活分组与发现。\n实操：在一个独立 Namespace 中，全流程部署 Redis 7.0（含自定义 Labels），完成从 YAML 编写、镜像加载、服务启动到 exec 验证及最终清理（干净的一）的完整生命周期管理。\n","permalink":"https://QwQBiG.github.io/posts/zuhui/","summary":"\u003ch2 id=\"组会报告-1\"\u003e组会报告 1\u003c/h2\u003e\n\u003cp\u003e容我想想上几周我干了什么：\u003c/p\u003e\n\u003cp\u003e首先在最开始，我搞了一个VMware开始玩弄Ubuntu，这个时候，我是在有这个项目通知之前，到货了一个鸿蒙系统的平板（书接上回），凭借“来都来了”与“捣鼓捣鼓”的心态，我开始安装搞termux和X11，想着搞个linux终端玩玩，但是因为鸿蒙，所以是无法启动的，但是我都看了好几个视频了，还是想试试linux，所以从电脑装了VMware，我这边是跟着千峰的（BV1VH1aBtEz2 ）视频来的，主要学的是虚拟机相关内容，同时包括一些Ubuntu命令：基础的ls,apt,tree,cd,pwd,cat,管道，重定向等，安装了插件：vmtools,samba,一些命令提示组件啥的（还有TheFuck，白月光），接触了主要是用SSH协议的Xshell远程终端（最后扔了）。算是对linux的Ubuntu发行版有了基础认识哈。（千峰的东西还是太过时了qwq）\u003c/p\u003e\n\u003cp\u003e然后就是新机必做的美化，有道是：”用着爽不一定真爽，但看着爽一定是真爽。“终端是块黑黢黢的方块，字体是被压缩成俄式比例的，那确实很可怕了\u0026hellip;那时还没找毛学长，没搞zsh，终端还是bash，此时搞了个kitty图形化终端，以此来搞出来壁纸画面；之后开始使用oh my zsh和字体pl10k，搞出了jb momo（全拼一直忘）和代码高亮，和右键补全，这时的我受到豆沙包和臭鲸鱼的极致恶心，所幸镜像一天10次对话的ChatGPT还像是个人\u0026hellip;但是还是让我感觉出，整这种相对完整的内容，还是博客、论坛、b站（一般）啥的好一些，我的美化，是跟着收藏的一篇CSDN的文章搞得（安装oh-my-zsh，配置命令行高亮，命令提示，打造高效终端_oh my zsh-CSDN博客）。终于，也是有了一个好看些的Ubuntu。\u003c/p\u003e\n\u003cp\u003e或许，我们感觉美化有点搞偏了，但是也可以学到pip,git一些下载、拉镜像源的方法，比如说找马云对吧（Gitee）。就像是孔老二说的可以“兴观群怨”的《诗经》，退一步说，这也算是一种识字教育，见识这些奇怪的“鸟兽草木之名”，也有帮助。\u003c/p\u003e\n\u003cp\u003e之后，我深刻的了解到、并可以熟练进行Ubuntu的紧急操作界面的恢复\u0026hellip;因为可能是我把第二个开的虚拟机，放到了第一个虚拟机没有清理完全的文件夹，导致lvm卷他找不到，那两天左右，我大概有20次以上的重启到紧急模式到好了到测试的经历，可以说是十分熟练（酸爽）了。\u003c/p\u003e\n\u003cp\u003e然后转折点：毛学长给我分了一块实验室服务器的Ubuntu，所以开始搞远程终端的美化：\u003c/p\u003e\n\u003cp\u003e最终是扔了Xshell，用了开源的Tabby Terminal，如下图（还没整）哈，这么多好用的远程，难道主要是因为这个有壁纸插件吗？还真是。插件好啊，点下安装就让用。\u003c/p\u003e\n\u003cp\u003e然后，在我回宿舍路上，想要点开终端fuck一下，猛然发现连接寄掉了，原因都知道，这是在实验室的内网，问学长让我瞅瞅内网穿透，我听着有点高级哈，”穿透“，像是网安的词。当我下载、点开樱花穿透后：发现，这不是我的世界联机用的吗hh。由此，以及后来用的panel.frplients，以及学长给到的http协议的代理，都是，额，应该是计算机网络都要学的内容，TCP/SSH/HTTP/HTTPS这些协议嗯。以及一点防火墙的设置，都有学到。\u003c/p\u003e\n\u003cp\u003e在这些内容的中间，从linux(BV1cq421w72c )到docker（BV14s4y1i7Vf ）（BV1THKyzBER6 ）的基础视频，我是跟着敲了的。当然docker pull 不了镜像，问ai快给我俩问四了，发现是另有缘由是吧（当然有了代理，一路畅通）。\u003c/p\u003e\n\u003cp\u003e看的相关的科普视频关于docker,k8s,k3s,docker compose,docker swarm\u0026hellip;比较杂\u0026hellip;\u003c/p\u003e\n\u003cp\u003e然后就是调教ai（为了多玩玩docker），想搞个网站，一开始是吧，docker建了个文件夹搞点html,css做了个界面，发现内网\u0026hellip;然后拉了一个wordpress是个动态网站，依旧内网\u0026hellip;再看域名，看累了没搞，之后还想内网穿透，结果https\u0026hellip;相关视频看了大概，网络协议也是大概学到了一些\u0026hellip;\u003c/p\u003e\n\u003cp\u003e最终是用的Github Pages静态网站，不用自己搞sql、redis啥的，也不用搞安全，还是很爽的，加上Github Action 发布文章只要win终端git push一下就好了。\u003c/p\u003e\n\u003cp\u003e这边，主要是接触了git、前端代码、以及重要的shell内容。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://qwqbig.github.io/\"\u003ehttps://qwqbig.github.io/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e网址如上，里面有建站的全流程，想看的话。我应该有两天时间再干这个。\u003c/p\u003e\n\u003cp\u003e最后这两天就感到有点子无聊了，回到了STL 和 C++11以上的好的特性上去玩。\u003c/p\u003e\n\u003cp\u003e那我正好鼓捣k8s玩了，还以为要再docker几天的。\u003c/p\u003e\n\u003cp\u003e对了，我学过py（第一个学的就是py），脚本方面的接触在网站上建站过程中提及到了也。\u003c/p\u003e\n\u003cp\u003e本来我都想开始把原来做的题用cpp重写的，像是把这个世界用Rust重写一遍似的\u0026hellip;(话说蟹教有干翻C++的未来吗，不清楚)。\u003c/p\u003e\n\u003cp\u003e写日记挺好玩的，我要同步到https://qwqbig.github.io/上hhh\u003c/p\u003e\n\u003cp\u003e欧克，完事了，bye~\u003c/p\u003e\n\u003ch2 id=\"组会报告-2\"\u003e组会报告 2\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e总结：本周主要搞了 K8s 本地环境的网络与镜像难题，完成了从 kubectl 命令式操作到 YAML 声明式管理的思维转变，掌握了 Pod 高级模式（Sidecar）、资源隔离（Namespace/Labels）及标准排错流程。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e主要是 K8s 本地环境搭建与 Pod 编排\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. 可恶的网：Kind + 国内源\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e由于 Minikube 网络受限，转用 Kind (Kubernetes in Docker)。通过配置 GOPROXY 完成源码编译安装，配合 kind-config.yaml 定制国内镜像源及端口映射，解决了环境初始化问题。\u003c/p\u003e","title":"我の组会"},{"content":"\n你好，我是 QwQBiG。\n一名正在计算机科学道路上探索的大一新生。\n我创建这个博客，是为了记录我在学习编程、探索技术世界过程中的思考、笔记和项目实践。我相信，分享是最好的学习方式（有诗也发（或许吧））。\n我的兴趣 C++ 与算法 Qt 开发 Web 开发 （这是myai写的（笑）） Linux 系统 你可以在 GitHub 上找到我。欢迎通过任何方式与我交流！\n","permalink":"https://QwQBiG.github.io/about/","summary":"\u003cp\u003e\u003cimg alt=\"一只可爱的猫（？）\" loading=\"lazy\" src=\"/avatar.png\"\u003e\u003c/p\u003e\n\u003cp\u003e你好，我是 QwQBiG。\u003c/p\u003e\n\u003cp\u003e一名正在计算机科学道路上探索的大一新生。\u003c/p\u003e\n\u003cp\u003e我创建这个博客，是为了记录我在学习编程、探索技术世界过程中的思考、笔记和项目实践。我相信，分享是最好的学习方式（有诗也发（或许吧））。\u003c/p\u003e\n\u003ch3 id=\"我的兴趣\"\u003e我的兴趣\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eC++ 与算法\u003c/li\u003e\n\u003cli\u003eQt 开发\u003c/li\u003e\n\u003cli\u003eWeb 开发 （这是myai写的（笑））\u003c/li\u003e\n\u003cli\u003eLinux 系统\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e你可以在 \u003ca href=\"https://github.com/QwQBiG\"\u003eGitHub\u003c/a\u003e 上找到我。欢迎通过任何方式与我交流！\u003c/p\u003e","title":"我 是 谁（并非宝可梦）"},{"content":"文章列表 第一篇：STL 容器\n简介：人如其名\n第二篇：STL 算法\n简介：+1\n","permalink":"https://QwQBiG.github.io/series/learning-cpp/","summary":"\u003ch2 id=\"文章列表\"\u003e文章列表\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e第一篇：\u003ca href=\"../../posts/stlcontainer/\"\u003eSTL 容器\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e简介：人如其名\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e第二篇：\u003ca href=\"../../posts/stlalgorithm/\"\u003eSTL 算法\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e简介：+1\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"C++ STL"},{"content":"你好，世界！\n多年之后，看到这些文字，如今的你，是否还会想起，多年前看b站视频打印“hello world!”的那个遥远的下午\u0026hellip;\n如果你能看到这篇文章，那说明我成功了。作为一只冲浪老资历，我一直梦想拥有一个属于自己的、可以记录学习笔记、分享心得的个人博客（东方homo馆）。这便是我的“Hello World”——一个通往更广阔数字世界的起点。（兴许是“读瘾”犯了，要写点东西自己咂摸）\n溯洄从之，道阻且长。如同伊人，此间追寻的过程远比我想象的要曲折，但也比我想象的要收获更多。我遇到了各种各样的问题：从 Docker 的内网穿透失败（其实成功了（但是https）），到 Windows 开发环境的重重陷阱，再到网络连接的神秘莫测，最后到项目结构的频频阻折\u0026hellip;\n所幸“时来天地皆同力”，假借实验室老老资历学长给的焚诀（代理，ai，服务器的一块ubuntu\u0026hellip;）得以为今后的所有故事作一个序。\n而我的感觉是：尽管ai飞速发展，博客、论坛、群聊比比皆是，我自己搜寻资料时，找相应操作时，或者找一些有的没有的奇怪资源时，还是有些力不从心（主要是豆沙包和臭鲸鱼现在确实一般般（25.11））；加上我喜欢鼓捣些长久的、有趣的、有意味（意味深）的东西，顾影自怜，自我怀念，比如写诗著文，都是些艺术形式，于是便有了这个界面的出现。\n谁不想要一个自己的文章网站呢~\n现在，我想把这条被我“踩”出来的、不怕ta“爱而不见”的路，分享给你。\n最终技术栈 内容生成：Hugo (一个快如闪电的静态网站生成器) 免费托管：GitHub Pages (程序员的“免费虚拟主机”) 写作工具：VS Code + Markdown 语法 版本控制与部署：Git 本地环境：Windows 11 第一章：环境搭建——地基决定上层建筑 事实证明，一个干净、稳定、配置正确的本地开发环境，是所有成功的一半。在经历了多次失败后，我总结出以下在 Windows 上最可靠的安装流程。\n1. 安装 Scoop 包管理器 Scoop 是 Windows 上的一个命令行“应用商店”，能让软件安装变得极其简单。\n准备 PowerShell 打开一个普通用户权限的 PowerShell 窗口（不要“以管理员身份运行”），执行以下两条命令：\n1 2 Set-ExecutionPolicy RemoteSigned -Scope CurrentUser irm get.scoop.sh | iex 这里有趣的是如果管理员运行会报错，这是因为Scoop 的 “用户级” 设计哲学，十分不错。\n2. 安装所有核心工具 拥有了 Scoop，我们就可以一键安装所有需要的软件。\n1 2 3 4 5 6 7 8 9 10 11 12 # 安装 Git (版本控制) scoop install git # 安装 Go 语言 (Hugo 模块系统依赖) scoop install go # 安装 Hugo (网站生成器) scoop install hugo # 安装 VS Code (代码编辑器), 需要先添加 \u0026#39;extras\u0026#39; 仓库 scoop bucket add extras scoop install vscode 避坑指南：如果任何一条 scoop install 命令因为网络问题失败 (比如提示\u0026quot;远程方已关闭传输流\u0026quot;)，不要灰心，这是国内网络环境的常见问题。多试几次，或者考虑为 PowerShell 设置临时的网络代理。\n3. 为 Git 配置网络代理 为了确保后续能顺利地从 GitHub 下载主题和推送网站，我们需要为 Git 配置代理（如果你有代理工具的话）。这几乎是一劳永逸地解决网络问题的最佳方案。\n1 2 3 # 将 7890 替换成你自己的代理工具的 HTTP 端口 git config --global http.proxy http://127.0.0.1:7890 git config --global https.proxy https://127.0.0.1:7890 第二章：创建你的博客本体 环境就绪，现在开始盖房子。我选择将项目放在 D 盘，避免 C 盘系统重装带来的麻烦（依旧怕爆红）。\n1. 创建项目骨架 1 2 3 4 5 D: mkdir Projects cd Projects hugo new site my-blog cd my-blog 验证：运行 ls，确保 content、archetypes 等文件夹都已成功创建。\n2. 使用 Hugo Modules 配置主题 我们使用模块化的方式引入 PaperMod 这个简洁优雅的主题。\n1 2 3 4 5 6 # 初始化 git init hugo mod init my-blog # 打开 VS Code 编辑配置文件 code . 在 VS Code 里，清空 hugo.toml 文件，并粘贴以下内容。注意：baseURL 必须换成你自己的 GitHub Pages 网址！\n1 2 3 4 5 6 7 baseURL = \u0026#34;https://QwQBiG.github.io/\u0026#34; # 换成你的！ languageCode = \u0026#34;en-us\u0026#34; title = \u0026#34;QwQBiG\u0026#39;s Blog\u0026#34; # 换成你的博客标题 theme = \u0026#34;github.com/adityatelange/hugo-PaperMod\u0026#34; [params] ShowCodeCopyButtons = true 3. 下载主题 1 hugo mod tidy 这条命令会读取配置文件，并自动下载所需的主题模块。\n第三章：日常写作与发布 这是你以后会日复一日重复的流程。\n1. 创作与预览 1 2 3 4 5 # 创建一篇新文章 hugo new content posts/my-first-post.md # 启动本地实时预览服务器 hugo server 现在，打开浏览器访问 http://localhost:1313。然后去 VS Code 里编辑 content/posts/my-first-post.md 文件（记得把 draft: true 改成 false），你所有的修改都会在浏览器里实时呈现。\n2. 发布到全世界 当你在本地预览满意后，就可以正式发布了。\n第一步：在 GitHub 创建仓库 创建一个公开仓库，名称必须是 你的用户名.github.io。\n第二步：构建并部署 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # (在 my-blog 根目录) 停止本地服务器 (Ctrl+C) # 1. 构建最终的网站文件到 public 文件夹 hugo # 2. 进入 public 文件夹 cd public # 3. 将 public 文件夹作为独立的 Git 仓库推送到线上 git init # 首次部署需要配置用户信息和远程地址 git config --global user.name \u0026#34;你的GitHub用户名\u0026#34; git config --global user.email \u0026#34;你的GitHub注册邮箱\u0026#34; git remote add origin https://github.com/你的用户名/你的用户名.github.io.git # 添加所有文件，提交并强制推送到 main 分支 git add . git commit -m \u0026#34;发布我的第一篇文章！\u0026#34; git branch -M main git push --force -u origin main #最后这一步如果报错可以多试两次，我经常是第二次才成功 避坑指南：整个部署流程最致命的错误，就是把 Git 仓库错误地初始化在了 my-blog 父目录，而不是 public 子目录。一定要确保你是在 public 文件夹里执行 git init 和后续命令！\n3. 最后的等待 GitHub Pages 需要几分钟来部署你的网站。之后，访问 https://你的用户名.github.io，并按下 Ctrl + Shift + R 强制刷新缓存，你就能看到你的成果了。如果其他设备暂时无法访问，请耐心等待 DNS 传播（吃口饭去吧）。\n第四章：重生之我是脚本小子（自动化） 我们每一次的发布还是太繁琐了，那\u0026hellip;就直接写个脚本吧！\n我们可以在项目根目录下创建一个 PowerShell 脚本文件，把所有命令都预先写好。以后，我们只需要运行这个脚本，就能完成所有部署操作。\n注意：我们也可以不用脚本自动化，可以借助GitHub Action实现，我放到了进阶教程里面哈。\n第一步：创建脚本文件 在你的博客项目根目录（my-blog）下，创建一个新文件，命名为 deploy.ps1。\n第二步：填入脚本代码 用 VS Code 打开 deploy.ps1，将以下代码完整地粘贴进去。这是一个纯英文、注释清晰、健壮可靠的版本，能避免所有因编码格式导致的奇怪错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 # ================================================================= # Hugo Deployment Script for GitHub Pages # Author: QwQBiG \u0026amp; hisai # Version: 2.0 (All-English, Robust) # ================================================================= # This script automates the entire process of building and deploying your Hugo site. # It requires one argument: a commit message for this deployment. param( [string]$commitMessage ) # --- Step 1: Validate Input --- if (-not $commitMessage) { Write-Host \u0026#34;ERROR: A commit message is required.\u0026#34; -ForegroundColor Red Write-Host \u0026#34;USAGE: .\\deploy.ps1 \\\u0026#34;Your meaningful commit message\\\u0026#34;\u0026#34; exit 1 } Write-Host \u0026#34;INFO: Starting deployment process...\u0026#34; -ForegroundColor Cyan # --- Step 2: Clean previous build --- Write-Host \u0026#34;INFO: Cleaning up the old \u0026#39;public\u0026#39; directory...\u0026#34; if (Test-Path -Path public) { Remove-Item -Recurse -Force public } # --- Step 3: Build the site with Hugo --- Write-Host \u0026#34;INFO: Building the website with Hugo...\u0026#34; hugo # --- Step 4: Verify the build was successful --- if (-not (Test-Path -Path public)) { Write-Host \u0026#34;ERROR: Hugo build failed. The \u0026#39;public\u0026#39; directory was not created.\u0026#34; -ForegroundColor Red exit 1 } Write-Host \u0026#34;INFO: Hugo build successful.\u0026#34; -ForegroundColor Green # --- Step 5: Navigate into the public directory --- cd public # --- Step 6: Deploy to GitHub --- Write-Host \u0026#34;INFO: Preparing to push to GitHub...\u0026#34; git init git remote add origin https://github.com/QwQBiG/QwQBiG.github.io.git git add . git commit -m \u0026#34;$commitMessage\u0026#34; git branch -M main Write-Host \u0026#34;INFO: Pushing files to the \u0026#39;main\u0026#39; branch...\u0026#34; git push --force -u origin main # --- Step 7: Finalize --- cd .. Write-Host \u0026#34;-----------------------------------------------------\u0026#34; Write-Host \u0026#34;SUCCESS: Deployment complete!\u0026#34; -ForegroundColor Green Write-Host \u0026#34;Your website has been successfully pushed to GitHub.\u0026#34; Write-Host \u0026#34;Please wait 1-2 minutes for GitHub Pages to update.\u0026#34; Write-Host \u0026#34;Then, remember to hard-refresh your browser (Ctrl+Shift+R).\u0026#34; Write-Host \u0026#34;-----------------------------------------------------\u0026#34; 第三步：如何使用 现在，你的发布流程被简化为一条命令：\n1 2 3 4 # 格式: .\\deploy.ps1 \u0026#34;你的发布说明\u0026#34; # 示例: .\\deploy.ps1 \u0026#34;发布我的第二篇文章\u0026#34; 避坑指南：首次运行的准备工作\n出于安全考虑，Windows PowerShell 默认可能不允许运行本地脚本。你需要以管理员身份打开 PowerShell，执行一次性设置：\n1 Set-ExecutionPolicy RemoteSigned 按 Y 确认即可。此后你的电脑就信任并允许运行你自己写的脚本了。\n第五章：主页大一统 1. 问题现象 你可能发现，最新发布的文章会\u0026quot;赤裸裸\u0026quot;地全文显示在主页顶部，没有卡片背景；而旧文章则以带背景的摘要卡片形式排列在下面。同时，你在 hugo.toml 里设置的博客总标题 title 也不见了。\n2. 根本原因 这是 Hugo PaperMod 主题默认的 \u0026ldquo;个人资料模式 (Profile Mode)\u0026rdquo;。它会将最新的一篇文章作为\u0026quot;精选内容\u0026quot;直接在主页展示全文，并隐藏网站总标题，以营造个人主页的氛围。\n但对于一个纯粹的博客，我们更想要一个所有文章样式统一的 \u0026ldquo;列表模式 (List Mode)\u0026rdquo;。\n3. 解决方案：修改 hugo.toml 我们只需要修改配置文件，明确告诉主题我们想要的主页样式。\n第一步：打开 hugo.toml 第二步：替换为推荐配置 将你的 hugo.toml 文件全部内容替换为下面的代码。这份配置不仅解决了布局问题，还额外添加了菜单导航等实用功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # hugo.toml (推荐的完整配置) baseURL = \u0026#34;https://QwQBiG.github.io/\u0026#34; #改成你的！！！ languageCode = \u0026#34;zh-cn\u0026#34; # 修改为中文，对主题更友好 title = \u0026#34;QwQBiG\u0026#39;s Blog\u0026#34; # 这是你的网站总标题 theme = \u0026#34;github.com/adityatelange/hugo-PaperMod\u0026#34; # 主菜单配置 [menu] [[menu.main]] identifier = \u0026#34;archives\u0026#34; name = \u0026#34;归档\u0026#34; url = \u0026#34;/archives/\u0026#34; weight = 10 [[menu.main]] identifier = \u0026#34;tags\u0026#34; name = \u0026#34;标签\u0026#34; url = \u0026#34;/tags/\u0026#34; weight = 20 # 这是最关键的参数配置部分 [params] ShowCodeCopyButtons = true # 1. 关闭特殊的\u0026#34;个人资料\u0026#34;主页模式 # 这会让你的主页变成一个标准的文章列表 [params.profileMode] enabled = false # 2. 在主页文章列表上方显示一个欢迎语 # 这会解决主标题不显示的问题，并让主页更好看 [params.homeInfoParams] Title = \u0026#34;你好，世界 👋\u0026#34; Content = \u0026#34;欢迎来到我的技术博客。在这里记录学习，分享心得。\u0026#34; # 3. 告诉主题，主页的文章列表主要来源于 \u0026#34;posts\u0026#34; 文件夹 mainSections = [\u0026#34;posts\u0026#34;] 第三步：重新部署 保存文件后，用我们全新的自动化脚本发布这次更新！\n1 .\\deploy.ps1 \u0026#34;Update theme settings for a professional homepage layout\u0026#34; 等待部署完成后，强制刷新你的网站。你会看到一个清爽、专业、所有文章样式统一的新主页！\nCongratulations!!!\n进阶内容！！！ 第六章：Giscus - 赋予博客“对话”的能力 静态博客自身无法处理评论，但我们可以嵌入一个基于 GitHub 的、免费且无广告的评论系统：Giscus。\n它的原理绝妙：将你 GitHub 仓库的 Discussions (讨论区) 功能，变成你博客文章的评论区。\n集成 Giscus 的正确步骤 第一步：核心准备 - 找到对的“家”\nGiscus 需要连接到你的博客源代码仓库。在我的实践中，我犯了一个错误，差点连错了地方。\nAha! 时刻：Giscus 需要连接的，就是你存放 hugo.toml 和 content/ 文件夹的那个仓库。对我来说，就是 QwQBiG/QwQBiG.github.io。 调试妙招：如果你不确定仓库的全名，可以在后面“安装 Giscus App”的步骤中，从“Only select repositories (仅选择仓库)”的下拉列表里找到并复制它，绝对不会错！ 第二步：为“家”开启讨论功能\n访问你的博客源代码仓库（例如 https://github.com/QwQBiG/QwQBiG.github.io）。 点击 Settings -\u0026gt; General -\u0026gt; Features。 找到 Discussions，给它打上勾。 第三步：邀请“管家” Giscus App 入住\n访问 Giscus 的应用主页：https://github.com/apps/giscus。 点击 Install，在接下来的页面选择 Only select repositories。 在下拉菜单中，务必勾选你的博客源代码仓库。 点击 Install \u0026amp; Authorize 完成安装。 第四步：在 Giscus 官网生成“门牌号”\n访问 https://giscus.app/。 在“仓库”一栏输入你的仓库全名。现在，因为你已经完成了所有准备，它会立刻成功识别！ 根据页面提示，完成设置（推荐映射关系选择 \u0026ldquo;Discussion title contains page pathname\u0026quot;）。 最后，它会为你生成一段 \u0026lt;script\u0026gt; 代码。复制它。 第五步：把“门牌号”挂到博客上\n在你的 my-blog 项目的 layouts/partials/ 路径下，创建一个新文件 comments.html。 将刚才复制的 \u0026lt;script\u0026gt; 代码完整地粘贴进去。 打开 hugo.toml 文件，在 [params] 的最下方加入代码，正式开启评论功能： 1 2 [params.comments] enabled = true 现在，部署你的网站。你会惊喜地发现，每篇文章下方，都有了一个功能完善的评论区！\n第七章：GitHub Actions - 你的云端部署机器人儿 我们之前做的 deploy.ps1 脚本很好玩，一行命令搞定一切，很有成就感。但它有一个\u0026quot;束缚\u0026rdquo;：它只能在我的电脑上运行。\n而 GitHub Actions，虽然配置文件看起来行数更多，但它提供的是一种更高维度的自动化。\n它是什么？ 一个住在你 GitHub 仓库里的免费机器人。你只要把代码 push 到仓库，剩下的所有部署工作，它在云端自动帮你完成。\n它比本地脚本强在哪里？ 随时随地：我可以在平板上、朋友的电脑上、甚至用手机网页版修改一个错字并提交，网站就会自动更新。我不再需要本地的 Hugo 环境和 PowerShell 脚本。 绝对稳定：云端环境是标准化的，永远不会出现\u0026quot;在我电脑上明明是好的\u0026quot;这种问题。 专业流程：这是行业标准，理解它，就等于理解了现代软件开发的核心理念之一：CI/CD（持续集成/持续部署）。 配置 GitHub Actions 的正确步骤 第一步：创建\u0026quot;机器人指令室\u0026quot; 在你的项目根目录，手动创建这样一个文件夹结构：.github/workflows/。\n第二步：编写\u0026quot;机器人指令集\u0026quot; 在 workflows 文件夹里，创建一个 deploy.yml 文件，把下面的\u0026quot;指令集\u0026quot;粘贴进去。\n注意：这份配置是为像我一样，在同一个仓库里进行开发和部署的场景量身定制的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 # .github/workflows/deploy.yml name: Deploy Hugo Site to Pages on: # 当 main 分支有 push 时触发 push: branches: - main jobs: build-and-deploy: runs-on: ubuntu-latest steps: # 第一步：机器人先\u0026#34;检出\u0026#34;你的代码 - name: Checkout uses: actions/checkout@v3 with: submodules: true # 获取主题等子模块 # 第二步：机器人安装 Hugo 环境 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true # 第三步：机器人运行 hugo 命令，构建网站 - name: Build run: hugo # 第四步：机器人将构建好的网站（public目录）部署到 gh-pages 分支 - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: # 这个令牌是 GitHub 自动提供的，无需设置 github_token: ${{ secrets.GITHUB_TOKEN }} # 我们要部署的分支是 gh-pages publish_branch: gh-pages # 部署的源文件夹是 public publish_dir: ./public 第三步：(仅需一次) 设定 GitHub Pages 的发布源 机器人现在会自动把网站发布到 gh-pages 这个分支了。我们需要告诉 GitHub Pages 去这个分支读取网站文件。\n访问你的仓库 Settings -\u0026gt; Pages 在 Build and deployment -\u0026gt; Source 这里，选择 Deploy from a branch 在下面的 Branch 下拉菜单中，选择 gh-pages 分支，然后点击 Save 提示：如果暂时没有 gh-pages 分支，没关系。你先提交一次代码，让机器人运行一次，这个分支就会自动出现，你再回来设置即可。\n总结：全新工作流 现在，你的博客之旅达到了一个全新的境界。\n写作：你只需要专注于在 content/ 文件夹里创建和修改 Markdown 文件 发布：你只需要 git push 就是这样。评论、部署、更新……所有的事情都已自动化。本地的 deploy.ps1 脚本可以光荣退役了（qwq）。\n第一步：在你的电脑上创作 想写新文章了？打开 PowerShell，进入 D:\\Projects\\my-blog 目录。\n运行命令：\n1 hugo new content posts/你的新文章标题.md 在 VS Code 里打开这个新文件，把 draft: false，然后尽情写作。\n第二步：在你的电脑上提交 文章写完并保存后，在 PowerShell 终端里，运行我们最熟悉的三条命令：\n1 2 3 git add . git commit -m \u0026#34;写了一篇关于...的新文章\u0026#34; git push 第三步：其他的一切，交给云端机器人 在你 push 成功的那一刻，你的所有工作就结束了。\n你不需要管 public 文件夹 你不需要管 gh-pages 分支 你不需要运行任何本地脚本 你的 GitHub Actions 机器人会自动被唤醒，在云端帮你完成所有构建和部署的脏活累活。几分钟后，你的新文章就会出现在全世界的面前。\n（Q）反问：登陆、安全和隐私呢？ （A）解答： 这是静态博客和动态博客（比如 WordPress）最大的不同之处，也是它的核心优势。\n登陆： 静态博客没有后台登陆。因为你的网站就是一堆纯粹的 HTML 文件，没有任何数据库或服务器程序在运行。你管理博客的方式，就是修改本地的 Markdown 文件，然后通过 Git 推送。评论区的\u0026quot;登陆\u0026quot;，实际上是授权 Giscus 使用读者的 GitHub 账号，与你的网站本身无关。\n安全： 静态博客极其安全！这是它最爽的地方。黑客们常攻击的是网站的数据库、后台漏洞、服务器程序。而你的网站只是一堆静态文件，没有任何程序可以攻击。黑客无法\u0026quot;黑进\u0026quot;你的网站，因为根本\u0026quot;无门可入\u0026quot;。你的安全由 GitHub 这样的大公司保障，远比自己维护一台服务器要安全得多。\n隐私： 你的网站本身不收集任何访客信息。但你集成的第三方服务（比如 Giscus）有它们自己的隐私策略。这是一个很好的习惯：可以在博客上创建一个\u0026quot;关于\u0026quot;页面或\u0026quot;隐私\u0026quot;页面，简单说明你使用了 Giscus 进行评论，并链接到 GitHub 的隐私政策。\n结语 最后用一句信达雅的名人名言结语：\nTalk is cheap,show me the code.(废话少说，放码过来。) \u0026ndash;Linus Torvalds\n我们可以发现：只要根据报错的代码，一步步走下来，计算机确实就没有什么“黑魔法”，而你就是甘道夫。\nNow,it\u0026rsquo;s your turn.\n","permalink":"https://QwQBiG.github.io/posts/hello-world/","summary":"\u003cp\u003e你好，世界！\u003c/p\u003e\n\u003cp\u003e多年之后，看到这些文字，如今的你，是否还会想起，多年前看b站视频打印“hello world!”的那个遥远的下午\u0026hellip;\u003c/p\u003e\n\u003cp\u003e如果你能看到这篇文章，那说明我成功了。作为一只冲浪老资历，我一直梦想拥有一个属于自己的、可以记录学习笔记、分享心得的个人博客（东方homo馆）。这便是我的“Hello World”——一个通往更广阔数字世界的起点。（兴许是“读瘾”犯了，要写点东西自己咂摸）\u003c/p\u003e\n\u003cp\u003e溯洄从之，道阻且长。如同伊人，此间追寻的过程远比我想象的要曲折，但也比我想象的要收获更多。我遇到了各种各样的问题：从 Docker 的内网穿透失败（其实成功了（但是https）），到 Windows 开发环境的重重陷阱，再到网络连接的神秘莫测，最后到项目结构的频频阻折\u0026hellip;\u003c/p\u003e\n\u003cp\u003e所幸“时来天地皆同力”，假借实验室老老资历学长给的焚诀（代理，ai，服务器的一块ubuntu\u0026hellip;）得以为今后的所有故事作一个序。\u003c/p\u003e\n\u003cp\u003e而我的感觉是：尽管ai飞速发展，博客、论坛、群聊比比皆是，我自己搜寻资料时，找相应操作时，或者找一些有的没有的奇怪资源时，还是有些力不从心（主要是豆沙包和臭鲸鱼现在确实一般般（25.11））；加上我喜欢鼓捣些长久的、有趣的、有意味（意味深）的东西，顾影自怜，自我怀念，比如写诗著文，都是些艺术形式，于是便有了这个界面的出现。\u003c/p\u003e\n\u003cp\u003e谁不想要一个自己的文章网站呢~\u003c/p\u003e\n\u003cp\u003e现在，我想把这条被我“踩”出来的、不怕ta“爱而不见”的路，分享给你。\u003c/p\u003e","title":"史诗级“Hello World”：如何从0到1（划掉）搭建个人技博（技术博客）"}]