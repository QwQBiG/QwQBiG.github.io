[{"content":"Docker 部署 FRP 客户端终极避坑指南 适用于： Linux (Ubuntu/CentOS) + Docker 环境，目标是穿透本地 SSH 或其他服务。\n核心结论 不要使用 Docker 默认的网络模式，直接使用 Host 模式 + 强制指定 DNS。\n这将解决：容器内网不通、DNS 解析失败、路由器重启导致 IP 变动失效等所有常见问题。\n1. 部署命令 (黄金标准版) 直接复制替换参数，一步到位：\n1 2 3 4 5 6 7 8 9 10 11 sudo docker run -d \\ --name frp-client \\ --restart=always \\ --network host \\ --dns 223.5.5.5 \\ --dns 8.8.8.8 \\ vaalacat/frp-panel \\ client -s \u0026lt;你的服务端Key\u0026gt; \\ -i \u0026lt;你的客户端ID\u0026gt; \\ --api-url \u0026lt;面板API地址\u0026gt; \\ --rpc-url \u0026lt;面板RPC地址\u0026gt; 本地地址 (Local IP): 填 127.0.0.1\n原因： 配合 Host 模式，127.0.0.1 永远指向本机。即使路由器分配的局域网 IP 变了（如 .12 变 .13），配置依然有效。\n本地端口 (Local Port): 填 22 (SSH) 或其他真实端口\n远程端口 (Remote Port): 填公网服务器已放行的端口 (如 8080, 2222 等)\n3. 故障排查速查表 如果状态不是 Online，按以下顺序检查：\n看日志 (唯一真理):\n1 sudo docker logs --tail 20 frp-client 常见报错及对策：\ndns lookup error / i/o timeout: 没加 --dns 参数，容器断网了。 connect to server failed: 公网服务器挂了，或参数填错。 connect to 127.0.0.1:22 connection refused: 没加 --network host 参数，容器里找不到 SSH 服务。 remote port is already in use: 公网端口被占，去网页换个远程端口。 一句话总结： Docker 跑 FRP，认准 --network host 和 --dns，内网 IP 填 127.0.0.1，永远不掉线。\n","permalink":"https://QwQBiG.github.io/posts/yuancheng/","summary":"\u003ch1 id=\"docker-部署-frp-客户端终极避坑指南\"\u003eDocker 部署 FRP 客户端终极避坑指南\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e适用于：\u003c/strong\u003e Linux (Ubuntu/CentOS) + Docker 环境，目标是穿透本地 SSH 或其他服务。\u003c/p\u003e\n\u003ch2 id=\"核心结论\"\u003e核心结论\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e不要使用 Docker 默认的网络模式，直接使用 Host 模式 + 强制指定 DNS。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e这将解决：容器内网不通、DNS 解析失败、路由器重启导致 IP 变动失效等所有常见问题。\u003c/p\u003e\n\u003ch2 id=\"1-部署命令-黄金标准版\"\u003e1. 部署命令 (黄金标准版)\u003c/h2\u003e\n\u003cp\u003e直接复制替换参数，一步到位：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo docker run -d \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e  --name frp-client \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e  --restart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003ealways \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e  --network host \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e  --dns 223.5.5.5 \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e  --dns 8.8.8.8 \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e  vaalacat/frp-panel \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e  client -s \u0026lt;你的服务端Key\u0026gt; \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e  -i \u0026lt;你的客户端ID\u0026gt; \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e  --api-url \u0026lt;面板API地址\u0026gt; \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e  --rpc-url \u0026lt;面板RPC地址\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e本地地址 (Local IP):\u003c/strong\u003e 填 \u003ccode\u003e127.0.0.1\u003c/code\u003e\u003c/p\u003e","title":"远程失灵了"},{"content":"文章列表 第一篇：K8s学习笔记\n简介：就是K8s\n第二篇：我の组会\n简介：每周二下午三点三楼组会（简称233）\n第三篇：远程失灵了\n简介：突发情况\n","permalink":"https://QwQBiG.github.io/series/yunwei/","summary":"\u003ch2 id=\"文章列表\"\u003e文章列表\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e第一篇：\u003ca href=\"../../posts/yunweistudy/\"\u003eK8s学习笔记\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e简介：就是K8s\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e第二篇：\u003ca href=\"../../posts/zuhui/\"\u003e我の组会\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e简介：每周二下午三点三楼组会（简称233）\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e第三篇：\u003ca href=\"../../posts/yuancheng/\"\u003e远程失灵了\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e简介：突发情况\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"运维"},{"content":"以下是2025.11.20第一次搞得周报 C已完。C++已学完STL容器和算法（和一些好玩的特性）。 数据结构在学STL都涉及了，纯学数据结构的话停留在串。 运维相关内容多且杂，具体内容见组会报告。\n之后有点东西都可以从这写着，刚做草稿： 比如今天，2025.11.23开始使用CLion来做Qt的程序。 而且，给网站上搞了一个昼夜切换的无敌按键（hhhh）。 还有猫猫砸钢琴音乐播放器！！！ 和闪光miku！\n","permalink":"https://QwQBiG.github.io/posts/zhouji/","summary":"\u003ch2 id=\"以下是20251120第一次搞得周报\"\u003e以下是2025.11.20第一次搞得周报\u003c/h2\u003e\n\u003cp\u003eC已完。C++已学完STL容器和算法（和一些好玩的特性）。\n数据结构在学STL都涉及了，纯学数据结构的话停留在串。\n运维相关内容多且杂，具体内容见组会报告。\u003c/p\u003e\n\u003ch3 id=\"之后有点东西都可以从这写着刚做草稿\"\u003e之后有点东西都可以从这写着，刚做草稿：\u003c/h3\u003e\n\u003cp\u003e比如今天，2025.11.23开始使用CLion来做Qt的程序。\n而且，给网站上搞了一个昼夜切换的无敌按键（hhhh）。\n还有猫猫砸钢琴音乐播放器！！！\n和闪光miku！\u003c/p\u003e","title":"我の周报"},{"content":"容器就是数据结构啦~\n","permalink":"https://QwQBiG.github.io/posts/stlcontainer/","summary":"\u003cp\u003e容器就是数据结构啦~\u003c/p\u003e","title":"STL 容器"},{"content":"算法最爽了~\n","permalink":"https://QwQBiG.github.io/posts/stlalgorithm/","summary":"\u003cp\u003e算法最爽了~\u003c/p\u003e","title":"STL 算法"},{"content":"Kubernetes 学习笔记 1 核心思想篇：两大基石 1. 为何选择 Kubernetes？ 单个 Docker 容器是孤立的。当容器数量增多，我们会面临一系列棘手的问题：\n故障恢复：一个容器挂了怎么办？ 服务发现：容器 B 如何找到容器 A 的 IP 地址？ 负载均衡：如何将流量平均分配给多个相同的容器？ 扩缩容：如何根据负载自动增加或减少容器数量？ Kubernetes (K8s) 就是一个容器编排平台，它以标准化的方式完美地解决了以上所有问题。\n2. 命令式 vs. 声明式 (转变) 命令式 (Imperative)：你一步步告诉 K8s “做什么” (kubectl create, kubectl scale)。这就像手动驾驶，直观但难以追踪和重复。 声明式 (Declarative)：你向 K8s 提交一个 YAML 文件，告诉它你**“想要什么状态”**。这就像设定导航目的地，K8s 会自己想办法开车到达，并且如果偏离了航线（比如有 Pod 挂了），它会自动修正。这是 K8s 的精髓，也是现代化的管理方式。 环境搭建篇：Kind (Kubernetes in Docker) 在复杂的网络环境下，使用 Kind 搭建本地集群是最可靠、轻量且快速的方式。\n1. 安装核心工具 安装 kubectl (K8s 命令行客户端)\n1 2 # (根据官方文档，使用 apt 或其他包管理器安装) sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install -y kubectl 安装 Go 语言环境 (用于安装 Kind)\n1 sudo apt-get install golang-go -y 设置 Go 国内代理并安装 kind\n这是解决网络问题的关键，goproxy.cn 会加速模块下载。\n1 2 3 export GOPROXY=https://goproxy.cn,direct go install sigs.k8s.io/kind@v0.22.0 sudo mv ~/go/bin/kind /usr/local/bin/ 验证安装\n1 2 kubectl version --client kind version 2. 编写 Kind 集群配置文件 这份文件解决了两个关键问题：① K8s 核心组件镜像的拉取问题；② 虚拟机端口冲突问题。\n创建 kind-config.yaml 文件： 1 nano kind-config.yaml 粘贴以下内容： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 kind: Cluster apiVersion: kind.x-k8s.io/v1alpha4 # 解决 K8s 核心组件镜像拉取问题 kubeadmConfigPatches: - | apiVersion: kubeadm.k8s.io/v1beta3 kind: ClusterConfiguration imageRepository: registry.aliyuncs.com/google_containers nodes: - role: control-plane kubeadmConfigPatches: - | kind: InitConfiguration nodeRegistration: kubeletExtraArgs: node-labels: \u0026#34;ingress-ready=true\u0026#34; # 解决宿主机端口占用问题，将 80/443 映射到高位端口 extraPortMappings: - containerPort: 80 hostPort: 52014 protocol: TCP - containerPort: 443 hostPort: 52015 protocol: TCP 3. 启动与销毁集群 启动集群 1 kind create cluster --config=kind-config.yaml 验证集群就绪 1 2 kubectl get nodes # 预期输出一个名为 kind-control-plane 的节点，状态为 Ready 销毁集群 (学习结束时) 1 kind delete cluster YAML 核心篇：Pod 的“蓝图” 1. YAML 四段式结构 apiVersion: API 版本，如 v1 kind: 资源类型，如 Pod metadata: 元数据，包括 name, namespace, labels spec: 期望状态，定义了资源的核心属性 2. 单容器 Pod 示例 1 2 3 4 5 6 7 8 9 10 apiVersion: v1 kind: Pod metadata: name: my-nginx-pod spec: containers: - name: nginx-container image: nginx:1.22 ports: - containerPort: 80 3. 多容器 Pod (Sidecar 模式) 与数据共享 通过 volumes 和 volumeMounts 实现一个 Pod 内多个容器间的文件共享。\nspec.volumes: 在 Pod 层面定义一个共享存储卷（“储藏室”）。 spec.containers[].volumeMounts: 在容器层面将共享卷挂载到容器内的特定路径（“开一扇门到储藏室”）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 apiVersion: v1 kind: Pod metadata: name: multi-container-demo spec: # 1. 定义一个名为 \u0026#34;shared-html\u0026#34; 的共享卷 volumes: - name: shared-html emptyDir: {} containers: # 容器一：Nginx - name: nginx-container image: nginx:1.22 # 2. 将共享卷挂载到 Nginx 的网站根目录 volumeMounts: - name: shared-html mountPath: /usr/share/nginx/html # 容器二：Busybox (Sidecar) - name: sidecar-container image: busybox:1.35 command: [\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;while true; do date \u0026gt;\u0026gt; /var/log/index.html; sleep 5; done\u0026#34;] # 3. 将同一个共享卷挂载到 Busybox 的日志目录 volumeMounts: - name: shared-html mountPath: /var/log 日常操作与调试篇 (kubectl) 1. 核心管理命令 应用配置: kubectl apply -f [文件名.yaml] 删除资源: kubectl delete -f [文件名.yaml] 或 kubectl delete pod [pod名] 2. 状态检查“三板斧” kubectl get : 快速查看资源列表和状态。 kubectl get pods: 查看当前命名空间的 Pod。 kubectl get pods -n \u0026lt;命名空间\u0026gt;: 查看指定命名空间的 Pod。 kubectl get pods -A: 查看所有命名空间的 Pod。 kubectl get pods -o wide: 查看更多信息（IP, 所在节点）。 kubectl describe : 查看资源的详细信息和事件日志。 kubectl describe pod \u0026lt;pod名\u0026gt; 排错关键：永远第一时间查看最下方的 Events 部分，它记录了 Pod 创建过程中的所有成功和失败信息。\nkubectl logs : 查看容器内部的标准输出日志。 kubectl logs \u0026lt;pod名\u0026gt; kubectl logs \u0026lt;pod名\u0026gt; -c \u0026lt;容器名\u0026gt;: 查看多容器 Pod 中特定容器的日志。 kubectl logs \u0026lt;pod名\u0026gt; --previous: 查看上一次崩溃退出的容器的日志。 3. 交互命令 kubectl exec : 进入一个正在运行的容器内部。 1 kubectl exec -it \u0026lt;pod名\u0026gt; -c \u0026lt;容器名\u0026gt; -- /bin/bash 4. 资源组织 Namespace (文件夹): 用于逻辑隔离。\n创建: kubectl create namespace \u0026lt;命名空间名\u0026gt; 删除: kubectl delete namespace \u0026lt;命名空间名\u0026gt; (会删除其内部所有资源) Labels \u0026amp; Selectors (标签与筛选器): 用于对资源进行分组和筛选。\n在 metadata.labels 中定义键值对。 使用 -l 参数进行筛选: kubectl get pods -l app=my-app,env=prod 实战排错篇：网络问题终极方案 问题现象: ImagePullBackOff / ErrImagePull Pod 状态显示拉取镜像失败，describe 事件中提示 i/o timeout 或 not found。\n方案一：(推荐) 修改 YAML，使用国内镜像源 直接在 YAML 的 image 字段中使用国内的、可访问的镜像地址。\n1 2 3 4 5 6 spec: containers: - name: redis-container # 原镜像: image: redis:7.0 # 修改后: image: m.daocloud.io/docker.io/library/redis:7.0 方案二：(极端网络环境) 本地加载 当所有镜像源都无法从 Kind 节点内部访问时，采用“主机下载，加载进集群”的策略。\n在主机 (Ubuntu VM) 上拉取镜像\n1 docker pull m.daocloud.io/docker.io/library/redis:7.0 为镜像打上官方标签 (关键)\nK8s Pod 的 YAML 里使用的是官方短名称，所以必须打这个标签。\n1 docker tag m.daocloud.io/docker.io/library/redis:7.0 redis:7.0 将打好标签的镜像加载进 Kind 集群\n1 kind load docker-image redis:7.0 最后，使用包含官方短名称 (image: redis:7.0) 的 YAML 文件进行部署。 K8s 会直接使用节点上的本地镜像，不再进行网络拉取。\nKubernetes 学习周报 2 核心主题：从\u0026quot;裸砖\u0026quot;到\u0026quot;自动化建筑\u0026quot; - Pod 的高级管理 从管理单个、脆弱的 Pod，过渡到使用 Deployment 和 Service 来部署、管理和暴露真正健壮、高可用的应用。\n第一部分：环境搭建与镜像管理（基础） 1. 搭建本地 Kubernetes (Kind) 环境 目标： 在本地快速搭建一个功能完整的 K8s 集群用于学习和实验。\n工具： Kind (Kubernetes in Docker)，它将 K8s 节点作为 Docker 容器运行，启动快，资源占用少。\n关键步骤：\n安装 kind CLI：\n1 2 3 4 # 推荐：为 Go 语言设置国内代理，然后通过 go install 安装 export GOPROXY=https://goproxy.cn,direct go install sigs.k8s.io/kind@v0.22.0 sudo mv ~/go/bin/kind /usr/local/bin/ 备注： 这是解决国内网络环境下 kind 程序下载困难的最佳实践。GOPROXY 环境变量是关键。\n编写 kind-config.yaml 配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 kind: Cluster apiVersion: kind.x-k8s.io/v1alpha4 nodes: - role: control-plane # 关键配置1: 端口映射，用于后续从主机访问 NodePort 服务 extraPortMappings: - containerPort: 30007 # Kind 节点(容器)内部的端口 hostPort: 8080 # 映射到宿主机(VM或物理机)的端口 protocol: TCP # 关键配置2: 指定 K8s 核心组件的镜像仓库 kubeadmConfigPatches: - | apiVersion: kubeadm.k8s.io/v1beta3 kind: ClusterConfiguration imageRepository: registry.aliyuncs.com/google_containers 解释：\nextraPortMappings：提前规划端口，解决 NodePort 服务在复杂网络环境下（如VM、远程服务器）难以直接访问的问题。 imageRepository：将 K8s 核心组件的镜像源指向国内的阿里云，从根本上解决了因网络问题导致的集群创建失败。 创建集群：\n1 kind create cluster --config=kind-config.yaml 2. 镜像管理：一劳永逸的\u0026quot;镜像预加载\u0026quot;SOP 问题背景： 在受限的网络环境中，K8s 节点（Kubelet）无法直接从 Docker Hub 等官方源拉取应用镜像，导致 Pod 状态卡在 ImagePullBackOff 或 ErrImagePull。\n核心思想： 既然 K8s 节点自己\u0026quot;出不去\u0026quot;，我们就在网络通畅的主机上把镜像准备好，然后强行\u0026quot;塞\u0026quot;给它。\n标准操作流程 (SOP)：\n【拉取】 在主机终端，从可靠的国内镜像源（如 m.daocloud.io）拉取镜像。\n1 docker pull m.daocloud.io/docker.io/library/nginx:1.22 【标记】 为拉取下来的镜像打上官方的\u0026quot;短名称\u0026quot;标签。这是为了让镜像名与 YAML 文件中的 image 字段完全匹配。\n1 docker tag m.daocloud.io/docker.io/library/nginx:1.22 nginx:1.22 【加载】 使用 kind load 命令，将主机上的镜像复制到 Kind 集群的内部镜像仓库中。\n1 kind load docker-image nginx:1.22 备注： 养成习惯，在部署任何包含新镜像的应用前，都先执行此\u0026quot;三部曲\u0026quot;。这能 100% 避免因镜像拉取失败导致的部署问题，极大提高学习和实验效率。\n第二部分：核心控制器 - Deployment 1. 为何需要 Deployment：告别\u0026quot;裸Pod\u0026quot; \u0026ldquo;裸Pod\u0026quot;的脆弱性： 直接创建的 Pod，在被删除、所在节点宕机或自身进程崩溃后，会永久消失，导致服务中断。\nDeployment 的价值：\n高可用性 (自愈能力): Deployment 通过管理 ReplicaSet，确保始终有预定数量的 Pod 副本在运行。当有 Pod 意外消失时，它会自动创建一个新的来替代。 可伸缩性: 可以轻松地增加或减少 Pod 的副本数量，以应对流量变化。 声明式更新: 提供强大的滚动更新和回滚机制，实现应用的平滑发布和快速修复。 2. 编写 Deployment YAML 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 apiVersion: apps/v1 # Deployment 属于 apps API 组 kind: Deployment metadata: name: my-app # Deployment 的名字 spec: replicas: 3 # 期望状态：需要 3 个 Pod 副本 # selector: 定义了 Deployment 如何\u0026#34;识别\u0026#34;它应该管理的孩子(Pod) selector: matchLabels: app: my-app # 匹配所有带有 \u0026#34;app: my-app\u0026#34; 标签的 Pod # template: Pod 的\u0026#34;出生模板\u0026#34; template: metadata: # 关键：模板中的 Pod 必须带有能与 selector 匹配的标签 labels: app: my-app spec: # 这里是标准的 Pod.spec 定义 containers: - name: nginx image: nginx:1.22 ports: - containerPort: 80 核心关系解释： Deployment 通过 spec.selector 来找到并管理 Pods。ReplicaSet (由 Deployment 自动创建) 则根据 spec.template 来创建新的 Pod。template.metadata.labels 和 selector.matchLabels 之间的匹配是它们能协同工作的关键。\n3. 核心运维操作 部署与查看：\n1 2 3 4 kubectl apply -f \u0026lt;deployment.yaml\u0026gt; kubectl get deployment kubectl get replicaset # 查看 Deployment 创建的 rs kubectl get pods # 查看 rs 创建的 pods 伸缩 (Scaling)：\n命令式 (快速): kubectl scale deployment my-app --replicas=5 声明式 (推荐): 修改 YAML 文件中的 replicas 字段，然后重新 kubectl apply 滚动更新 (Rolling Update)：\n修改 YAML 文件中的 template.spec.containers[0].image 字段为新版本 执行 kubectl apply -f \u0026lt;deployment.yaml\u0026gt; 监控更新过程： 1 2 3 4 # 实时观察 Pod 的增删交替过程 kubectl get pods -w # 查看官方的滚动更新状态报告 kubectl rollout status deployment/my-app 回滚 (Rollback)：\n查看历史版本：kubectl rollout history deployment/my-app 一键回滚到上一个版本：kubectl rollout undo deployment/my-app 回滚到指定版本：kubectl rollout undo deployment/my-app --to-revision=\u0026lt;NUMBER\u0026gt; 第三部分：服务发现 - Service 1. 为何需要 Service：解决 Pod 的\u0026quot;动态\u0026quot;问题 问题背景： Deployment 管理的 Pod IP 地址是动态的、不固定的，且 Pod 会随时被销毁和重建。应用之间无法直接通过 Pod IP 进行可靠通信。\nService 的价值： 为一组功能相同的 Pod 提供一个稳定、统一的访问入口。它有固定的虚拟 IP (ClusterIP) 和 DNS 名称，并能自动对后端的健康 Pod 进行负载均衡。\n2. Service 类型与实践 ClusterIP (默认类型 - 对内交通) 用途： 用于集群内部服务之间的通信，是构建微服务架构的基础。\nYAML 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 apiVersion: v1 kind: Service metadata: name: my-app-svc # Service 的名字，也是内部的 DNS 名 spec: type: ClusterIP # 可省略 # selector: Service 如何找到它要代理的 Pod selector: app: my-app # 匹配所有带 \u0026#34;app: my-app\u0026#34; 标签的 Pod ports: - port: 80 # Service 自身监听的端口 targetPort: 80 # 转发到后端 Pod 容器的目标端口 测试方法： 启动一个临时的调试 Pod，通过 Service 的 DNS 名称访问。\n1 2 3 4 # 启动临时 Pod 并进入 shell kubectl run tester --rm -it --image=busybox:1.35 -- /bin/sh # 在临时 Pod 内部访问 / # wget -O- http://my-app-svc NodePort (对外暴露 - 开发/测试用) 用途： 在 ClusterIP 的基础上，在集群的每个节点上都暴露一个相同的静态端口（30000-32767），从而允许从集群外部访问。\nYAML 示例 (在 ClusterIP 基础上修改)：\n1 2 3 4 5 6 7 8 spec: type: NodePort # 明确指定类型 selector: app: my-app ports: - port: 80 targetPort: 80 nodePort: 30007 # 可选，手动指定一个端口方便访问 测试方法：\n获取节点的 IP 地址 (对于 Kind in VM，是 VM 的 IP) 在本地浏览器中访问 http://\u0026lt;Node-IP\u0026gt;:\u0026lt;NodePort\u0026gt; kubectl port-forward (终极调试工具) 用途： 当 NodePort 因复杂的网络环境（防火墙、云安全组）无法访问时，这是最可靠的本地调试方法。\n原理： 在本地机器和指定的 Pod/Service 之间建立一个安全的流量转发隧道。\n使用方法：\n1 2 3 4 # 在一个终端中运行，它会阻塞 kubectl port-forward svc/my-app-svc 8888:80 # 在另一个终端中，访问本地的 8888 端口 curl http://localhost:8888 Kubernetes 学习周报 3 核心思想：十二因子应用 (The Twelve-Factor App) 本周所有学习内容的理论基石，源于云原生开发的最佳实践，特别是第三条：在环境中存储配置。\n目标： 将配置 (Config) 与代码/镜像彻底分离。\n优势：\n高效： 修改配置无需重新构建镜像。 灵活： 同一个镜像可以无缝部署到不同环境（开发、测试、生产）。 安全： 敏感信息（如密码）不会被硬编码到镜像中。 Kubernetes 解决方案：\n非敏感配置：ConfigMap 敏感配置：Secret 运行时数据/文件：Volume 一、ConfigMap：非敏感配置管理 ConfigMap 以键值对（key-value）的形式存储非敏感的配置数据。\n1. 创建 ConfigMap 方式A：从字面值创建 (适用于少量、简单的键值对)\n1 2 # 格式: kubectl create configmap \u0026lt;NAME\u0026gt; --from-literal=\u0026lt;KEY1\u0026gt;=\u0026lt;VALUE1\u0026gt; ... kubectl create configmap my-app-config --from-literal=APP_COLOR=blue --from-literal=APP_GREETING=\u0026#34;Hello World\u0026#34; 方式B：从文件创建 (适用于已有的配置文件)\n1 2 3 4 5 # 1. 先创建本地文件 echo \u0026#34;APP_MODE=production\u0026#34; \u0026gt; app.properties # 2. 从文件创建ConfigMap (文件名将作为key，文件内容作为value) kubectl create configmap my-app-config-from-file --from-file=app.properties 2. 使用 ConfigMap 方式一：作为环境变量注入 Pod 这是最符合\u0026quot;十二因子\u0026quot;理念的方式。Kubelet 在启动容器前，会将指定的 ConfigMap 值设置为容器的环境变量。\npod-with-cm-env.yaml 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 apiVersion: v1 kind: Pod metadata: name: pod-cm-env spec: containers: - name: test-container image: busybox:1.35 # 严谨的 echo 命令，用 \\\u0026#34;...\\\u0026#34; 包围变量以处理空格 command: [ \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;echo The app color is $APP_COLOR and the greeting is \\\u0026#34;$APP_GREETING\\\u0026#34;; sleep 3600\u0026#34; ] env: - name: APP_COLOR # 在容器中定义的环境变量名 valueFrom: configMapKeyRef: # 引用一个ConfigMap的key name: my-app-config # ConfigMap的名字 key: APP_COLOR # ConfigMap中的key - name: APP_GREETING valueFrom: configMapKeyRef: name: my-app-config key: APP_GREETING 部署与验证：\n1 2 3 4 5 6 # 部署前，必须先创建依赖的ConfigMap kubectl create configmap my-app-config --from-literal=APP_COLOR=blue --from-literal=APP_GREETING=\u0026#34;Hello World\u0026#34; # 部署Pod kubectl apply -f pod-with-cm-env.yaml # 查看日志验证 kubectl logs pod-cm-env 方式二：作为文件挂载到 Pod 适用于需要读取传统配置文件的应用。\npod-with-cm-volume.yaml 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 apiVersion: v1 kind: Pod metadata: name: pod-cm-volume spec: containers: - name: test-container image: busybox:1.35 command: [ \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;cat /etc/config/app.properties; sleep 3600\u0026#34; ] # 步骤2: 把下面定义的Volume挂载到容器的指定路径 volumeMounts: - name: config-volume mountPath: /etc/config # 步骤1: 在Pod层面定义一个Volume，数据来源是ConfigMap volumes: - name: config-volume configMap: name: my-app-config-from-file 二、Secret：敏感信息管理 Secret 专用于存储密码、API密钥等敏感数据。其使用方式与 ConfigMap 几乎完全一样，但有关键区别。\n核心区别：\n用途： 专用于敏感数据。 编码： 值默认进行 Base64 编码（注意：不是加密！）。 安全： K8s 会对其提供更强的安全机制（如静态加密、访问控制、内存存储等）。 1. 创建 Secret 1 2 # 格式: kubectl create secret generic \u0026lt;NAME\u0026gt; --from-literal=\u0026lt;KEY1\u0026gt;=\u0026lt;VALUE1\u0026gt; ... kubectl create secret generic db-credentials --from-literal=username=admin --from-literal=password=\u0026#39;S3cr3tP@ssw0rd!\u0026#39; 2. 使用 Secret 与 ConfigMap 类似，仅需将 configMapKeyRef 替换为 secretKeyRef，或将 configMap: 替换为 secret:。\npod-with-secret.yaml (环境变量注入) 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 apiVersion: v1 kind: Pod metadata: name: pod-with-secret spec: containers: - name: test-container image: busybox:1.35 command: [ \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;echo User is $DB_USER and Password is \\\u0026#34;$DB_PASS\\\u0026#34;; sleep 3600\u0026#34; ] env: - name: DB_USER valueFrom: secretKeyRef: # \u0026lt;-- 关键区别 name: db-credentials key: username - name: DB_PASS valueFrom: secretKeyRef: # \u0026lt;-- 关键区别 name: db-credentials key: password 部署与验证：\n1 2 3 4 5 6 # 部署前，必须先创建依赖的Secret kubectl create secret generic db-credentials --from-literal=username=admin --from-literal=password=\u0026#39;S3cr3tP@ssw0rd!\u0026#39; # 部署Pod kubectl apply -f pod-with-secret.yaml # 查看日志验证 (仅用于学习，生产环境严禁打印密码) kubectl logs pod-with-secret 三、Volume：Pod 的存储卷 Volume 是连接外部存储和 Pod 的桥梁，其生命周期与 Pod 绑定（Pod 在，Volume 在）。\n1. emptyDir：Pod 内的临时共享存储 特性：\nPod 创建时，K8s 在节点上为其分配一个空目录。 Pod 删除时，该目录及其内容被永久删除。 容器崩溃重启，数据不丢失。 核心用途： 同一个 Pod 内多个容器之间共享文件（Sidecar 模式）。\nSidecar 示例 pod-with-emptydir.yaml:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 apiVersion: v1 kind: Pod metadata: name: web-server-pod spec: volumes: - name: shared-html emptyDir: {} # 定义一个emptyDir类型的Volume containers: - name: web-server image: nginx volumeMounts: # 挂载Volume - name: shared-html mountPath: /usr/share/nginx/html - name: content-generator image: busybox command: [\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;while true; do echo \\\u0026#34;Generated at $(date)\\\u0026#34; \u0026gt; /html/index.html; sleep 5; done\u0026#34;] volumeMounts: # 挂载同一个Volume - name: shared-html mountPath: /html 验证方法 (端口转发):\n1 2 3 4 # 在一个终端运行 kubectl port-forward pod/web-server-pod 8080:80 # 在另一个终端验证 curl http://localhost:8080 2. hostPath：与节点主机的存储交互 特性：\n将 Node 主机上的文件或目录直接挂载到 Pod 中。 数据不会随 Pod 删除而消失。 重大风险： 破坏 Pod 可移植性，带来严重安全风险。应极力避免在常规应用中使用。 核心用途： 日志收集、监控代理等需要访问节点底层资源的系统级应用。\npod-with-hostpath.yaml 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 apiVersion: v1 kind: Pod metadata: name: pod-hostpath spec: containers: - name: test-container image: busybox:1.35 command: [ \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;cat /host-data/host-file.txt; sleep 3600\u0026#34; ] volumeMounts: - name: host-storage mountPath: /host-data volumes: - name: host-storage hostPath: path: /mnt/data # 指定要挂载的主机路径 type: Directory 验证方法：\n1 2 3 4 5 6 7 8 9 # 1. 进入Kind节点容器，创建文件 docker exec -it kind-control-plane /bin/bash # root@kind-control-plane:/# mkdir /mnt/data # root@kind-control-plane:/# echo \u0026#34;Hello from Host\u0026#34; \u0026gt; /mnt/data/host-file.txt # root@kind-control-plane:/# exit # 2. 部署Pod kubectl apply -f pod-with-hostpath.yaml # 3. 查看日志 kubectl logs pod-hostpath 突发状况：远程失效了 总结下来就是：Docker 跑 FRP，认准 --network host 和 --dns，内网 IP 填 127.0.0.1，永远不掉线。\n","permalink":"https://QwQBiG.github.io/posts/yunweistudy/","summary":"\u003ch1 id=\"kubernetes-学习笔记-1\"\u003eKubernetes 学习笔记 1\u003c/h1\u003e\n\u003ch2 id=\"核心思想篇两大基石\"\u003e核心思想篇：两大基石\u003c/h2\u003e\n\u003ch3 id=\"1-为何选择-kubernetes\"\u003e1. 为何选择 Kubernetes？\u003c/h3\u003e\n\u003cp\u003e单个 Docker 容器是孤立的。当容器数量增多，我们会面临一系列棘手的问题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e故障恢复\u003c/strong\u003e：一个容器挂了怎么办？\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e服务发现\u003c/strong\u003e：容器 B 如何找到容器 A 的 IP 地址？\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e负载均衡\u003c/strong\u003e：如何将流量平均分配给多个相同的容器？\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e扩缩容\u003c/strong\u003e：如何根据负载自动增加或减少容器数量？\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eKubernetes (K8s) 就是一个\u003cstrong\u003e容器编排平台\u003c/strong\u003e，它以标准化的方式完美地解决了以上所有问题。\u003c/p\u003e\n\u003ch3 id=\"2-命令式-vs-声明式-转变\"\u003e2. 命令式 vs. 声明式 (转变)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e命令式 (Imperative)\u003c/strong\u003e：你一步步告诉 K8s \u003cstrong\u003e“做什么”\u003c/strong\u003e (\u003ccode\u003ekubectl create\u003c/code\u003e, \u003ccode\u003ekubectl scale\u003c/code\u003e)。这就像手动驾驶，直观但难以追踪和重复。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e声明式 (Declarative)\u003c/strong\u003e：你向 K8s 提交一个 YAML 文件，告诉它你**“想要什么状态”**。这就像设定导航目的地，K8s 会自己想办法开车到达，并且如果偏离了航线（比如有 Pod 挂了），它会自动修正。\u003cstrong\u003e这是 K8s 的精髓，也是现代化的管理方式。\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"环境搭建篇kind-kubernetes-in-docker\"\u003e环境搭建篇：Kind (Kubernetes in Docker)\u003c/h2\u003e\n\u003cp\u003e在复杂的网络环境下，使用 Kind 搭建本地集群是最可靠、轻量且快速的方式。\u003c/p\u003e\n\u003ch3 id=\"1-安装核心工具\"\u003e1. 安装核心工具\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e安装 \u003ccode\u003ekubectl\u003c/code\u003e (K8s 命令行客户端)\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# (根据官方文档，使用 apt 或其他包管理器安装)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt-get update \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e sudo apt-get install -y kubectl\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e安装 Go 语言环境 (用于安装 Kind)\u003c/strong\u003e\u003c/p\u003e","title":"K8s学习笔记"},{"content":"组会报告 1 容我想想上几周我干了什么：\n首先在最开始，我搞了一个VMware开始玩弄Ubuntu，这个时候，我是在有这个项目通知之前，到货了一个鸿蒙系统的平板（书接上回），凭借“来都来了”与“捣鼓捣鼓”的心态，我开始安装搞termux和X11，想着搞个linux终端玩玩，但是因为鸿蒙，所以是无法启动的，但是我都看了好几个视频了，还是想试试linux，所以从电脑装了VMware，我这边是跟着千峰的（BV1VH1aBtEz2 ）视频来的，主要学的是虚拟机相关内容，同时包括一些Ubuntu命令：基础的ls,apt,tree,cd,pwd,cat,管道，重定向等，安装了插件：vmtools,samba,一些命令提示组件啥的（还有TheFuck，白月光），接触了主要是用SSH协议的Xshell远程终端（最后扔了）。算是对linux的Ubuntu发行版有了基础认识哈。（千峰的东西还是太过时了qwq）\n然后就是新机必做的美化，有道是：”用着爽不一定真爽，但看着爽一定是真爽。“终端是块黑黢黢的方块，字体是被压缩成俄式比例的，那确实很可怕了\u0026hellip;那时还没找毛学长，没搞zsh，终端还是bash，此时搞了个kitty图形化终端，以此来搞出来壁纸画面；之后开始使用oh my zsh和字体pl10k，搞出了jb momo（全拼一直忘）和代码高亮，和右键补全，这时的我受到豆沙包和臭鲸鱼的极致恶心，所幸镜像一天10次对话的ChatGPT还像是个人\u0026hellip;但是还是让我感觉出，整这种相对完整的内容，还是博客、论坛、b站（一般）啥的好一些，我的美化，是跟着收藏的一篇CSDN的文章搞得（安装oh-my-zsh，配置命令行高亮，命令提示，打造高效终端_oh my zsh-CSDN博客）。终于，也是有了一个好看些的Ubuntu。\n或许，我们感觉美化有点搞偏了，但是也可以学到pip,git一些下载、拉镜像源的方法，比如说找马云对吧（Gitee）。就像是孔老二说的可以“兴观群怨”的《诗经》，退一步说，这也算是一种识字教育，见识这些奇怪的“鸟兽草木之名”，也有帮助。\n之后，我深刻的了解到、并可以熟练进行Ubuntu的紧急操作界面的恢复\u0026hellip;因为可能是我把第二个开的虚拟机，放到了第一个虚拟机没有清理完全的文件夹，导致lvm卷他找不到，那两天左右，我大概有20次以上的重启到紧急模式到好了到测试的经历，可以说是十分熟练（酸爽）了。\n然后转折点：毛学长给我分了一块实验室服务器的Ubuntu，所以开始搞远程终端的美化：\n最终是扔了Xshell，用了开源的Tabby Terminal，如下图（还没整）哈，这么多好用的远程，难道主要是因为这个有壁纸插件吗？还真是。插件好啊，点下安装就让用。\n然后，在我回宿舍路上，想要点开终端fuck一下，猛然发现连接寄掉了，原因都知道，这是在实验室的内网，问学长让我瞅瞅内网穿透，我听着有点高级哈，”穿透“，像是网安的词。当我下载、点开樱花穿透后：发现，这不是我的世界联机用的吗hh。由此，以及后来用的panel.frplients，以及学长给到的http协议的代理，都是，额，应该是计算机网络都要学的内容，TCP/SSH/HTTP/HTTPS这些协议嗯。以及一点防火墙的设置，都有学到。\n在这些内容的中间，从linux(BV1cq421w72c )到docker（BV14s4y1i7Vf ）（BV1THKyzBER6 ）的基础视频，我是跟着敲了的。当然docker pull 不了镜像，问ai快给我俩问四了，发现是另有缘由是吧（当然有了代理，一路畅通）。\n看的相关的科普视频关于docker,k8s,k3s,docker compose,docker swarm\u0026hellip;比较杂\u0026hellip;\n然后就是调教ai（为了多玩玩docker），想搞个网站，一开始是吧，docker建了个文件夹搞点html,css做了个界面，发现内网\u0026hellip;然后拉了一个wordpress是个动态网站，依旧内网\u0026hellip;再看域名，看累了没搞，之后还想内网穿透，结果https\u0026hellip;相关视频看了大概，网络协议也是大概学到了一些\u0026hellip;\n最终是用的Github Pages静态网站，不用自己搞sql、redis啥的，也不用搞安全，还是很爽的，加上Github Action 发布文章只要win终端git push一下就好了。\n这边，主要是接触了git、前端代码、以及重要的shell内容。\nhttps://qwqbig.github.io/\n网址如上，里面有建站的全流程，想看的话。我应该有两天时间在干这个。\n最后这两天就感到有点子无聊了，回到了 STL 和 C++11 以上的好的特性上去玩。\n那我正好鼓捣k8s玩了，还以为要再docker几天的。\n对了，我学过py（第一个学的就是py），脚本方面的接触在网站上建站过程中提及到了也。\n本来我都想开始把原来做的题用cpp重写的，像是把这个世界用Rust重写一遍似的\u0026hellip;(话说蟹教有干翻C++的未来吗，不清楚)。\n写日记挺好玩的，我要同步到https://qwqbig.github.io/上hhh\n欧克，完事了，bye~\n组会报告 2 总结：本周主要搞了 K8s 本地环境的网络与镜像难题，完成了从 kubectl 命令式操作到 YAML 声明式管理的思维转变，掌握了 Pod 高级（应该高级吧）模式（Sidecar）、资源隔离（Namespace/Labels）及标准排错流程。\n主要是 K8s 本地环境搭建与 Pod 编排： 1. 可恶的网：Kind + 国内源\n由于 Minikube 网络受限，转用 Kind (Kubernetes in Docker)。通过配置 GOPROXY 完成源码编译安装，配合 kind-config.yaml 定制国内镜像源及端口映射，解决了环境初始化问题。\n（Kind 把 Docker 容器当成 K8s 的节点（Node）来跑）\n2. 熟悉概念：从命令式到声明式\n基础：熟悉 kubectl 一些基础的动词语法，并且从命令式（CLI）转向声明式（YAML），主要是有版本控制（用 git ）这些好处。\n说是动词语法是因为这些命令的格式差别不大，基本上是动词的变化。\nPod 理解：通过实操 边车（Sidecar） 模式（Nginx + Busybox 共享存储），理解 Pod 作为“最小单元”的共享网络与存储特性。\n存储 是因为同一个卷，网络 是我配置到 YMAL 里面了。\n3. 运维与Debug方法\n镜像策略：对于 ImagePullBackOff，除了替换国内源（好不容易找到个 m.daocloud.io），还掌握了 docker pull + kind load 的离线镜像预加载手段。（就是有点大）\nDebug 流程：建立了标准排错链：若是资源调度问题（如 Crash/PullErr）用 kubectl describe 看 Events，应用内部报错查 kubectl logs。\n4. 搞一搞\n隔离：用 Namespace 进行环境隔离，利用 Labels/Selectors 实现资源的灵活分组与发现。\n实操：在一个全新的 Namespace 中，全流程部署 Redis 7.0（含自定义 Labels），完成从 YAML 编写、镜像加载、服务启动到 exec 验证（进入容器内部，试运行ls, cat 等命令，并 exit 退出。）及最终清理（干净的一）的完整管理周期。\n5.感觉\n为了上面关于运维的内容简洁清晰，我都没有地方说点好玩的废话了，我要先表明我的学习路径，主要一脉相承自我学 STL 的时候，b站上的系统课程 cpp 版本是史前的，内容是繁（烦）多的，一个 sort 用上 lambda 不香嘛、有了范围 for 还用迭代器遍历干啥捏\u0026hellip;\u0026hellip;所以我是去和 ai 搞暧昧玩（？）， ai 回应快，时效性强，可以反复问\u0026hellip;我让她先给出到明年那种学习程度的每个月的学习路径，然后开一个新窗口让她详细来，在一周周的来，发现根本用不了几周几周的，总之就是 快！像催人跑（川音）\u0026hellip;\n但是问题还是有的，这些学习学出来感觉空落落的，像是我这个破网站上搞搞好玩的前端内容，可以直接看到、点击到；我学Qt框架，整出来一个计算器确实简单点的计算可以用到。但是就像学个编程语言光搞算法做题玩了，要想来个工程项目，大抵很难；学运维的这些东西，还是有些难以检验学习成果的\u0026hellip;\u0026hellip;\n就这样。\n组会报告 3 依旧是草稿施工： 好玩的：我在测试自愈时，删除完了立马 kubectl get pods -w 都看不到旧的 Pod 的 Terminating ，只能看见新的 Pod 。\n感受：没有什么问题是加一个中间层解决不了的，如果有，就再来一层。\n","permalink":"https://QwQBiG.github.io/posts/zuhui/","summary":"\u003ch2 id=\"组会报告-1\"\u003e组会报告 1\u003c/h2\u003e\n\u003cp\u003e容我想想上几周我干了什么：\u003c/p\u003e\n\u003cp\u003e首先在最开始，我搞了一个VMware开始玩弄Ubuntu，这个时候，我是在有这个项目通知之前，到货了一个鸿蒙系统的平板（书接上回），凭借“来都来了”与“捣鼓捣鼓”的心态，我开始安装搞termux和X11，想着搞个linux终端玩玩，但是因为鸿蒙，所以是无法启动的，但是我都看了好几个视频了，还是想试试linux，所以从电脑装了VMware，我这边是跟着千峰的（BV1VH1aBtEz2 ）视频来的，主要学的是虚拟机相关内容，同时包括一些Ubuntu命令：基础的ls,apt,tree,cd,pwd,cat,管道，重定向等，安装了插件：vmtools,samba,一些命令提示组件啥的（还有TheFuck，白月光），接触了主要是用SSH协议的Xshell远程终端（最后扔了）。算是对linux的Ubuntu发行版有了基础认识哈。（千峰的东西还是太过时了qwq）\u003c/p\u003e\n\u003cp\u003e然后就是新机必做的美化，有道是：”用着爽不一定真爽，但看着爽一定是真爽。“终端是块黑黢黢的方块，字体是被压缩成俄式比例的，那确实很可怕了\u0026hellip;那时还没找毛学长，没搞zsh，终端还是bash，此时搞了个kitty图形化终端，以此来搞出来壁纸画面；之后开始使用oh my zsh和字体pl10k，搞出了jb momo（全拼一直忘）和代码高亮，和右键补全，这时的我受到豆沙包和臭鲸鱼的极致恶心，所幸镜像一天10次对话的ChatGPT还像是个人\u0026hellip;但是还是让我感觉出，整这种相对完整的内容，还是博客、论坛、b站（一般）啥的好一些，我的美化，是跟着收藏的一篇CSDN的文章搞得（安装oh-my-zsh，配置命令行高亮，命令提示，打造高效终端_oh my zsh-CSDN博客）。终于，也是有了一个好看些的Ubuntu。\u003c/p\u003e\n\u003cp\u003e或许，我们感觉美化有点搞偏了，但是也可以学到pip,git一些下载、拉镜像源的方法，比如说找马云对吧（Gitee）。就像是孔老二说的可以“兴观群怨”的《诗经》，退一步说，这也算是一种识字教育，见识这些奇怪的“鸟兽草木之名”，也有帮助。\u003c/p\u003e\n\u003cp\u003e之后，我深刻的了解到、并可以熟练进行Ubuntu的紧急操作界面的恢复\u0026hellip;因为可能是我把第二个开的虚拟机，放到了第一个虚拟机没有清理完全的文件夹，导致lvm卷他找不到，那两天左右，我大概有20次以上的重启到紧急模式到好了到测试的经历，可以说是十分熟练（酸爽）了。\u003c/p\u003e\n\u003cp\u003e然后转折点：毛学长给我分了一块实验室服务器的Ubuntu，所以开始搞远程终端的美化：\u003c/p\u003e\n\u003cp\u003e最终是扔了Xshell，用了开源的Tabby Terminal，如下图（还没整）哈，这么多好用的远程，难道主要是因为这个有壁纸插件吗？还真是。插件好啊，点下安装就让用。\u003c/p\u003e\n\u003cp\u003e然后，在我回宿舍路上，想要点开终端fuck一下，猛然发现连接寄掉了，原因都知道，这是在实验室的内网，问学长让我瞅瞅内网穿透，我听着有点高级哈，”穿透“，像是网安的词。当我下载、点开樱花穿透后：发现，这不是我的世界联机用的吗hh。由此，以及后来用的panel.frplients，以及学长给到的http协议的代理，都是，额，应该是计算机网络都要学的内容，TCP/SSH/HTTP/HTTPS这些协议嗯。以及一点防火墙的设置，都有学到。\u003c/p\u003e\n\u003cp\u003e在这些内容的中间，从linux(BV1cq421w72c )到docker（BV14s4y1i7Vf ）（BV1THKyzBER6 ）的基础视频，我是跟着敲了的。当然docker pull 不了镜像，问ai快给我俩问四了，发现是另有缘由是吧（当然有了代理，一路畅通）。\u003c/p\u003e\n\u003cp\u003e看的相关的科普视频关于docker,k8s,k3s,docker compose,docker swarm\u0026hellip;比较杂\u0026hellip;\u003c/p\u003e\n\u003cp\u003e然后就是调教ai（为了多玩玩docker），想搞个网站，一开始是吧，docker建了个文件夹搞点html,css做了个界面，发现内网\u0026hellip;然后拉了一个wordpress是个动态网站，依旧内网\u0026hellip;再看域名，看累了没搞，之后还想内网穿透，结果https\u0026hellip;相关视频看了大概，网络协议也是大概学到了一些\u0026hellip;\u003c/p\u003e\n\u003cp\u003e最终是用的Github Pages静态网站，不用自己搞sql、redis啥的，也不用搞安全，还是很爽的，加上Github Action 发布文章只要win终端git push一下就好了。\u003c/p\u003e\n\u003cp\u003e这边，主要是接触了git、前端代码、以及重要的shell内容。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://qwqbig.github.io/\"\u003ehttps://qwqbig.github.io/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e网址如上，里面有建站的全流程，想看的话。我应该有两天时间在干这个。\u003c/p\u003e\n\u003cp\u003e最后这两天就感到有点子无聊了，回到了 STL 和 C++11 以上的好的特性上去玩。\u003c/p\u003e\n\u003cp\u003e那我正好鼓捣k8s玩了，还以为要再docker几天的。\u003c/p\u003e\n\u003cp\u003e对了，我学过py（第一个学的就是py），脚本方面的接触在网站上建站过程中提及到了也。\u003c/p\u003e\n\u003cp\u003e本来我都想开始把原来做的题用cpp重写的，像是把这个世界用Rust重写一遍似的\u0026hellip;(话说蟹教有干翻C++的未来吗，不清楚)。\u003c/p\u003e\n\u003cp\u003e写日记挺好玩的，我要同步到https://qwqbig.github.io/上hhh\u003c/p\u003e\n\u003cp\u003e欧克，完事了，bye~\u003c/p\u003e\n\u003ch2 id=\"组会报告-2\"\u003e组会报告 2\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e总结：本周主要搞了 K8s 本地环境的网络与镜像难题，完成了从 kubectl 命令式操作到 YAML 声明式管理的思维转变，掌握了 Pod 高级（应该高级吧）模式（Sidecar）、资源隔离（Namespace/Labels）及标准排错流程。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch4 id=\"主要是-k8s-本地环境搭建与-pod-编排\"\u003e主要是 K8s 本地环境搭建与 Pod 编排：\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e1. 可恶的网：Kind + 国内源\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e由于 Minikube 网络受限，转用 Kind (Kubernetes in Docker)。通过配置 GOPROXY 完成源码编译安装，配合 kind-config.yaml 定制国内镜像源及端口映射，解决了环境初始化问题。\u003c/p\u003e","title":"我の组会"},{"content":"\n你好，我是 QwQBiG。\n一名正在计算机科学道路上探索的大一新生。\n我创建这个博客，是为了记录我在学习编程、探索技术世界过程中的思考、笔记和项目实践。我相信，分享是最好的学习方式（有诗也发（或许吧））。\n我的兴趣 C++ 与算法 Qt 开发 Web 开发 （这是myai写的（笑）） Linux 系统 你可以在 GitHub 上找到我。欢迎通过任何方式与我交流！\n","permalink":"https://QwQBiG.github.io/about/","summary":"\u003cp\u003e\u003cimg alt=\"一只可爱的猫（？）\" loading=\"lazy\" src=\"/avatar.png\"\u003e\u003c/p\u003e\n\u003cp\u003e你好，我是 QwQBiG。\u003c/p\u003e\n\u003cp\u003e一名正在计算机科学道路上探索的大一新生。\u003c/p\u003e\n\u003cp\u003e我创建这个博客，是为了记录我在学习编程、探索技术世界过程中的思考、笔记和项目实践。我相信，分享是最好的学习方式（有诗也发（或许吧））。\u003c/p\u003e\n\u003ch3 id=\"我的兴趣\"\u003e我的兴趣\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eC++ 与算法\u003c/li\u003e\n\u003cli\u003eQt 开发\u003c/li\u003e\n\u003cli\u003eWeb 开发 （这是myai写的（笑））\u003c/li\u003e\n\u003cli\u003eLinux 系统\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e你可以在 \u003ca href=\"https://github.com/QwQBiG\"\u003eGitHub\u003c/a\u003e 上找到我。欢迎通过任何方式与我交流！\u003c/p\u003e","title":"我 是 谁（并非宝可梦）"},{"content":"文章列表 第一篇：STL 容器\n简介：人如其名\n第二篇：STL 算法\n简介：+1\n","permalink":"https://QwQBiG.github.io/series/learning-cpp/","summary":"\u003ch2 id=\"文章列表\"\u003e文章列表\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e第一篇：\u003ca href=\"../../posts/stlcontainer/\"\u003eSTL 容器\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e简介：人如其名\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e第二篇：\u003ca href=\"../../posts/stlalgorithm/\"\u003eSTL 算法\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e简介：+1\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"C++ STL"},{"content":"你好，世界！\n多年之后，看到这些文字，如今的你，是否还会想起，多年前看b站视频打印“hello world!”的那个遥远的下午\u0026hellip;\n如果你能看到这篇文章，那说明我成功了。作为一只冲浪老资历，我一直梦想拥有一个属于自己的、可以记录学习笔记、分享心得的个人博客（东方homo馆）。这便是我的“Hello World”——一个通往更广阔数字世界的起点。（兴许是“读瘾”犯了，要写点东西自己咂摸）\n溯洄从之，道阻且长。如同伊人，此间追寻的过程远比我想象的要曲折，但也比我想象的要收获更多。我遇到了各种各样的问题：从 Docker 的内网穿透失败（其实成功了（但是https）），到 Windows 开发环境的重重陷阱，再到网络连接的神秘莫测，最后到项目结构的频频阻折\u0026hellip;\n所幸“时来天地皆同力”，假借实验室老老资历学长给的焚诀（代理，ai，服务器的一块ubuntu\u0026hellip;）得以为今后的所有故事作一个序。\n而我的感觉是：尽管ai飞速发展，博客、论坛、群聊比比皆是，我自己搜寻资料时，找相应操作时，或者找一些有的没有的奇怪资源时，还是有些力不从心（主要是豆沙包和臭鲸鱼现在确实一般般（25.11））；加上我喜欢鼓捣些长久的、有趣的、有意味（意味深）的东西，顾影自怜，自我怀念，比如写诗著文，都是些艺术形式，于是便有了这个界面的出现。\n谁不想要一个自己的文章网站呢~\n现在，我想把这条被我“踩”出来的、不怕ta“爱而不见”的路，分享给你。\n最终技术栈 内容生成：Hugo (一个快如闪电的静态网站生成器) 免费托管：GitHub Pages (程序员的“免费虚拟主机”) 写作工具：VS Code + Markdown 语法 版本控制与部署：Git 本地环境：Windows 11 第一章：环境搭建——地基决定上层建筑 事实证明，一个干净、稳定、配置正确的本地开发环境，是所有成功的一半。在经历了多次失败后，我总结出以下在 Windows 上最可靠的安装流程。\n1. 安装 Scoop 包管理器 Scoop 是 Windows 上的一个命令行“应用商店”，能让软件安装变得极其简单。\n准备 PowerShell 打开一个普通用户权限的 PowerShell 窗口（不要“以管理员身份运行”），执行以下两条命令：\n1 2 Set-ExecutionPolicy RemoteSigned -Scope CurrentUser irm get.scoop.sh | iex 这里有趣的是如果管理员运行会报错，这是因为Scoop 的 “用户级” 设计哲学，十分不错。\n2. 安装所有核心工具 拥有了 Scoop，我们就可以一键安装所有需要的软件。\n1 2 3 4 5 6 7 8 9 10 11 12 # 安装 Git (版本控制) scoop install git # 安装 Go 语言 (Hugo 模块系统依赖) scoop install go # 安装 Hugo (网站生成器) scoop install hugo # 安装 VS Code (代码编辑器), 需要先添加 \u0026#39;extras\u0026#39; 仓库 scoop bucket add extras scoop install vscode 避坑指南：如果任何一条 scoop install 命令因为网络问题失败 (比如提示\u0026quot;远程方已关闭传输流\u0026quot;)，不要灰心，这是国内网络环境的常见问题。多试几次，或者考虑为 PowerShell 设置临时的网络代理。\n3. 为 Git 配置网络代理 为了确保后续能顺利地从 GitHub 下载主题和推送网站，我们需要为 Git 配置代理（如果你有代理工具的话）。这几乎是一劳永逸地解决网络问题的最佳方案。\n1 2 3 # 将 7890 替换成你自己的代理工具的 HTTP 端口 git config --global http.proxy http://127.0.0.1:7890 git config --global https.proxy https://127.0.0.1:7890 第二章：创建你的博客本体 环境就绪，现在开始盖房子。我选择将项目放在 D 盘，避免 C 盘系统重装带来的麻烦（依旧怕爆红）。\n1. 创建项目骨架 1 2 3 4 5 D: mkdir Projects cd Projects hugo new site my-blog cd my-blog 验证：运行 ls，确保 content、archetypes 等文件夹都已成功创建。\n2. 使用 Hugo Modules 配置主题 我们使用模块化的方式引入 PaperMod 这个简洁优雅的主题。\n1 2 3 4 5 6 # 初始化 git init hugo mod init my-blog # 打开 VS Code 编辑配置文件 code . 在 VS Code 里，清空 hugo.toml 文件，并粘贴以下内容。注意：baseURL 必须换成你自己的 GitHub Pages 网址！\n1 2 3 4 5 6 7 baseURL = \u0026#34;https://QwQBiG.github.io/\u0026#34; # 换成你的！ languageCode = \u0026#34;en-us\u0026#34; title = \u0026#34;QwQBiG\u0026#39;s Blog\u0026#34; # 换成你的博客标题 theme = \u0026#34;github.com/adityatelange/hugo-PaperMod\u0026#34; [params] ShowCodeCopyButtons = true 3. 下载主题 1 hugo mod tidy 这条命令会读取配置文件，并自动下载所需的主题模块。\n第三章：日常写作与发布 这是你以后会日复一日重复的流程。\n1. 创作与预览 1 2 3 4 5 # 创建一篇新文章 hugo new content posts/my-first-post.md # 启动本地实时预览服务器 hugo server 现在，打开浏览器访问 http://localhost:1313。然后去 VS Code 里编辑 content/posts/my-first-post.md 文件（记得把 draft: true 改成 false），你所有的修改都会在浏览器里实时呈现。\n2. 发布到全世界 当你在本地预览满意后，就可以正式发布了。\n第一步：在 GitHub 创建仓库 创建一个公开仓库，名称必须是 你的用户名.github.io。\n第二步：构建并部署 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # (在 my-blog 根目录) 停止本地服务器 (Ctrl+C) # 1. 构建最终的网站文件到 public 文件夹 hugo # 2. 进入 public 文件夹 cd public # 3. 将 public 文件夹作为独立的 Git 仓库推送到线上 git init # 首次部署需要配置用户信息和远程地址 git config --global user.name \u0026#34;你的GitHub用户名\u0026#34; git config --global user.email \u0026#34;你的GitHub注册邮箱\u0026#34; git remote add origin https://github.com/你的用户名/你的用户名.github.io.git # 添加所有文件，提交并强制推送到 main 分支 git add . git commit -m \u0026#34;发布我的第一篇文章！\u0026#34; git branch -M main git push --force -u origin main #最后这一步如果报错可以多试两次，我经常是第二次才成功 避坑指南：整个部署流程最致命的错误，就是把 Git 仓库错误地初始化在了 my-blog 父目录，而不是 public 子目录。一定要确保你是在 public 文件夹里执行 git init 和后续命令！\n3. 最后的等待 GitHub Pages 需要几分钟来部署你的网站。之后，访问 https://你的用户名.github.io，并按下 Ctrl + Shift + R 强制刷新缓存，你就能看到你的成果了。如果其他设备暂时无法访问，请耐心等待 DNS 传播（吃口饭去吧）。\n第四章：重生之我是脚本小子（自动化） 我们每一次的发布还是太繁琐了，那\u0026hellip;就直接写个脚本吧！\n我们可以在项目根目录下创建一个 PowerShell 脚本文件，把所有命令都预先写好。以后，我们只需要运行这个脚本，就能完成所有部署操作。\n注意：我们也可以不用脚本自动化，可以借助GitHub Action实现，我放到了进阶教程里面哈。\n第一步：创建脚本文件 在你的博客项目根目录（my-blog）下，创建一个新文件，命名为 deploy.ps1。\n第二步：填入脚本代码 用 VS Code 打开 deploy.ps1，将以下代码完整地粘贴进去。这是一个纯英文、注释清晰、健壮可靠的版本，能避免所有因编码格式导致的奇怪错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 # ================================================================= # Hugo Deployment Script for GitHub Pages # Author: QwQBiG \u0026amp; hisai # Version: 2.0 (All-English, Robust) # ================================================================= # This script automates the entire process of building and deploying your Hugo site. # It requires one argument: a commit message for this deployment. param( [string]$commitMessage ) # --- Step 1: Validate Input --- if (-not $commitMessage) { Write-Host \u0026#34;ERROR: A commit message is required.\u0026#34; -ForegroundColor Red Write-Host \u0026#34;USAGE: .\\deploy.ps1 \\\u0026#34;Your meaningful commit message\\\u0026#34;\u0026#34; exit 1 } Write-Host \u0026#34;INFO: Starting deployment process...\u0026#34; -ForegroundColor Cyan # --- Step 2: Clean previous build --- Write-Host \u0026#34;INFO: Cleaning up the old \u0026#39;public\u0026#39; directory...\u0026#34; if (Test-Path -Path public) { Remove-Item -Recurse -Force public } # --- Step 3: Build the site with Hugo --- Write-Host \u0026#34;INFO: Building the website with Hugo...\u0026#34; hugo # --- Step 4: Verify the build was successful --- if (-not (Test-Path -Path public)) { Write-Host \u0026#34;ERROR: Hugo build failed. The \u0026#39;public\u0026#39; directory was not created.\u0026#34; -ForegroundColor Red exit 1 } Write-Host \u0026#34;INFO: Hugo build successful.\u0026#34; -ForegroundColor Green # --- Step 5: Navigate into the public directory --- cd public # --- Step 6: Deploy to GitHub --- Write-Host \u0026#34;INFO: Preparing to push to GitHub...\u0026#34; git init git remote add origin https://github.com/QwQBiG/QwQBiG.github.io.git git add . git commit -m \u0026#34;$commitMessage\u0026#34; git branch -M main Write-Host \u0026#34;INFO: Pushing files to the \u0026#39;main\u0026#39; branch...\u0026#34; git push --force -u origin main # --- Step 7: Finalize --- cd .. Write-Host \u0026#34;-----------------------------------------------------\u0026#34; Write-Host \u0026#34;SUCCESS: Deployment complete!\u0026#34; -ForegroundColor Green Write-Host \u0026#34;Your website has been successfully pushed to GitHub.\u0026#34; Write-Host \u0026#34;Please wait 1-2 minutes for GitHub Pages to update.\u0026#34; Write-Host \u0026#34;Then, remember to hard-refresh your browser (Ctrl+Shift+R).\u0026#34; Write-Host \u0026#34;-----------------------------------------------------\u0026#34; 第三步：如何使用 现在，你的发布流程被简化为一条命令：\n1 2 3 4 # 格式: .\\deploy.ps1 \u0026#34;你的发布说明\u0026#34; # 示例: .\\deploy.ps1 \u0026#34;发布我的第二篇文章\u0026#34; 避坑指南：首次运行的准备工作\n出于安全考虑，Windows PowerShell 默认可能不允许运行本地脚本。你需要以管理员身份打开 PowerShell，执行一次性设置：\n1 Set-ExecutionPolicy RemoteSigned 按 Y 确认即可。此后你的电脑就信任并允许运行你自己写的脚本了。\n第五章：主页大一统 1. 问题现象 你可能发现，最新发布的文章会\u0026quot;赤裸裸\u0026quot;地全文显示在主页顶部，没有卡片背景；而旧文章则以带背景的摘要卡片形式排列在下面。同时，你在 hugo.toml 里设置的博客总标题 title 也不见了。\n2. 根本原因 这是 Hugo PaperMod 主题默认的 \u0026ldquo;个人资料模式 (Profile Mode)\u0026rdquo;。它会将最新的一篇文章作为\u0026quot;精选内容\u0026quot;直接在主页展示全文，并隐藏网站总标题，以营造个人主页的氛围。\n但对于一个纯粹的博客，我们更想要一个所有文章样式统一的 \u0026ldquo;列表模式 (List Mode)\u0026rdquo;。\n3. 解决方案：修改 hugo.toml 我们只需要修改配置文件，明确告诉主题我们想要的主页样式。\n第一步：打开 hugo.toml 第二步：替换为推荐配置 将你的 hugo.toml 文件全部内容替换为下面的代码。这份配置不仅解决了布局问题，还额外添加了菜单导航等实用功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # hugo.toml (推荐的完整配置) baseURL = \u0026#34;https://QwQBiG.github.io/\u0026#34; #改成你的！！！ languageCode = \u0026#34;zh-cn\u0026#34; # 修改为中文，对主题更友好 title = \u0026#34;QwQBiG\u0026#39;s Blog\u0026#34; # 这是你的网站总标题 theme = \u0026#34;github.com/adityatelange/hugo-PaperMod\u0026#34; # 主菜单配置 [menu] [[menu.main]] identifier = \u0026#34;archives\u0026#34; name = \u0026#34;归档\u0026#34; url = \u0026#34;/archives/\u0026#34; weight = 10 [[menu.main]] identifier = \u0026#34;tags\u0026#34; name = \u0026#34;标签\u0026#34; url = \u0026#34;/tags/\u0026#34; weight = 20 # 这是最关键的参数配置部分 [params] ShowCodeCopyButtons = true # 1. 关闭特殊的\u0026#34;个人资料\u0026#34;主页模式 # 这会让你的主页变成一个标准的文章列表 [params.profileMode] enabled = false # 2. 在主页文章列表上方显示一个欢迎语 # 这会解决主标题不显示的问题，并让主页更好看 [params.homeInfoParams] Title = \u0026#34;你好，世界 👋\u0026#34; Content = \u0026#34;欢迎来到我的技术博客。在这里记录学习，分享心得。\u0026#34; # 3. 告诉主题，主页的文章列表主要来源于 \u0026#34;posts\u0026#34; 文件夹 mainSections = [\u0026#34;posts\u0026#34;] 第三步：重新部署 保存文件后，用我们全新的自动化脚本发布这次更新！\n1 .\\deploy.ps1 \u0026#34;Update theme settings for a professional homepage layout\u0026#34; 等待部署完成后，强制刷新你的网站。你会看到一个清爽、专业、所有文章样式统一的新主页！\nCongratulations!!!\n进阶内容！！！ 第六章：Giscus - 赋予博客“对话”的能力 静态博客自身无法处理评论，但我们可以嵌入一个基于 GitHub 的、免费且无广告的评论系统：Giscus。\n它的原理绝妙：将你 GitHub 仓库的 Discussions (讨论区) 功能，变成你博客文章的评论区。\n集成 Giscus 的正确步骤 第一步：核心准备 - 找到对的“家”\nGiscus 需要连接到你的博客源代码仓库。在我的实践中，我犯了一个错误，差点连错了地方。\nAha! 时刻：Giscus 需要连接的，就是你存放 hugo.toml 和 content/ 文件夹的那个仓库。对我来说，就是 QwQBiG/QwQBiG.github.io。 调试妙招：如果你不确定仓库的全名，可以在后面“安装 Giscus App”的步骤中，从“Only select repositories (仅选择仓库)”的下拉列表里找到并复制它，绝对不会错！ 第二步：为“家”开启讨论功能\n访问你的博客源代码仓库（例如 https://github.com/QwQBiG/QwQBiG.github.io）。 点击 Settings -\u0026gt; General -\u0026gt; Features。 找到 Discussions，给它打上勾。 第三步：邀请“管家” Giscus App 入住\n访问 Giscus 的应用主页：https://github.com/apps/giscus。 点击 Install，在接下来的页面选择 Only select repositories。 在下拉菜单中，务必勾选你的博客源代码仓库。 点击 Install \u0026amp; Authorize 完成安装。 第四步：在 Giscus 官网生成“门牌号”\n访问 https://giscus.app/。 在“仓库”一栏输入你的仓库全名。现在，因为你已经完成了所有准备，它会立刻成功识别！ 根据页面提示，完成设置（推荐映射关系选择 \u0026ldquo;Discussion title contains page pathname\u0026quot;）。 最后，它会为你生成一段 \u0026lt;script\u0026gt; 代码。复制它。 第五步：把“门牌号”挂到博客上\n在你的 my-blog 项目的 layouts/partials/ 路径下，创建一个新文件 comments.html。 将刚才复制的 \u0026lt;script\u0026gt; 代码完整地粘贴进去。 打开 hugo.toml 文件，在 [params] 的最下方加入代码，正式开启评论功能： 1 2 [params.comments] enabled = true 现在，部署你的网站。你会惊喜地发现，每篇文章下方，都有了一个功能完善的评论区！\n第七章：GitHub Actions - 你的云端部署机器人儿 我们之前做的 deploy.ps1 脚本很好玩，一行命令搞定一切，很有成就感。但它有一个\u0026quot;束缚\u0026rdquo;：它只能在我的电脑上运行。\n而 GitHub Actions，虽然配置文件看起来行数更多，但它提供的是一种更高维度的自动化。\n它是什么？ 一个住在你 GitHub 仓库里的免费机器人。你只要把代码 push 到仓库，剩下的所有部署工作，它在云端自动帮你完成。\n它比本地脚本强在哪里？ 随时随地：我可以在平板上、朋友的电脑上、甚至用手机网页版修改一个错字并提交，网站就会自动更新。我不再需要本地的 Hugo 环境和 PowerShell 脚本。 绝对稳定：云端环境是标准化的，永远不会出现\u0026quot;在我电脑上明明是好的\u0026quot;这种问题。 专业流程：这是行业标准，理解它，就等于理解了现代软件开发的核心理念之一：CI/CD（持续集成/持续部署）。 配置 GitHub Actions 的正确步骤 第一步：创建\u0026quot;机器人指令室\u0026quot; 在你的项目根目录，手动创建这样一个文件夹结构：.github/workflows/。\n第二步：编写\u0026quot;机器人指令集\u0026quot; 在 workflows 文件夹里，创建一个 deploy.yml 文件，把下面的\u0026quot;指令集\u0026quot;粘贴进去。\n注意：这份配置是为像我一样，在同一个仓库里进行开发和部署的场景量身定制的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 # .github/workflows/deploy.yml name: Deploy Hugo Site to Pages on: # 当 main 分支有 push 时触发 push: branches: - main jobs: build-and-deploy: runs-on: ubuntu-latest steps: # 第一步：机器人先\u0026#34;检出\u0026#34;你的代码 - name: Checkout uses: actions/checkout@v3 with: submodules: true # 获取主题等子模块 # 第二步：机器人安装 Hugo 环境 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true # 第三步：机器人运行 hugo 命令，构建网站 - name: Build run: hugo # 第四步：机器人将构建好的网站（public目录）部署到 gh-pages 分支 - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: # 这个令牌是 GitHub 自动提供的，无需设置 github_token: ${{ secrets.GITHUB_TOKEN }} # 我们要部署的分支是 gh-pages publish_branch: gh-pages # 部署的源文件夹是 public publish_dir: ./public 第三步：(仅需一次) 设定 GitHub Pages 的发布源 机器人现在会自动把网站发布到 gh-pages 这个分支了。我们需要告诉 GitHub Pages 去这个分支读取网站文件。\n访问你的仓库 Settings -\u0026gt; Pages 在 Build and deployment -\u0026gt; Source 这里，选择 Deploy from a branch 在下面的 Branch 下拉菜单中，选择 gh-pages 分支，然后点击 Save 提示：如果暂时没有 gh-pages 分支，没关系。你先提交一次代码，让机器人运行一次，这个分支就会自动出现，你再回来设置即可。\n总结：全新工作流 现在，你的博客之旅达到了一个全新的境界。\n写作：你只需要专注于在 content/ 文件夹里创建和修改 Markdown 文件 发布：你只需要 git push 就是这样。评论、部署、更新……所有的事情都已自动化。本地的 deploy.ps1 脚本可以光荣退役了（qwq）。\n第一步：在你的电脑上创作 想写新文章了？打开 PowerShell，进入 D:\\Projects\\my-blog 目录。\n运行命令：\n1 hugo new content posts/你的新文章标题.md 在 VS Code 里打开这个新文件，把 draft: false，然后尽情写作。\n第二步：在你的电脑上提交 文章写完并保存后，在 PowerShell 终端里，运行我们最熟悉的三条命令：\n1 2 3 git add . git commit -m \u0026#34;写了一篇关于...的新文章\u0026#34; git push 第三步：其他的一切，交给云端机器人 在你 push 成功的那一刻，你的所有工作就结束了。\n你不需要管 public 文件夹 你不需要管 gh-pages 分支 你不需要运行任何本地脚本 你的 GitHub Actions 机器人会自动被唤醒，在云端帮你完成所有构建和部署的脏活累活。几分钟后，你的新文章就会出现在全世界的面前。\n（Q）反问：登陆、安全和隐私呢？ （A）解答： 这是静态博客和动态博客（比如 WordPress）最大的不同之处，也是它的核心优势。\n登陆： 静态博客没有后台登陆。因为你的网站就是一堆纯粹的 HTML 文件，没有任何数据库或服务器程序在运行。你管理博客的方式，就是修改本地的 Markdown 文件，然后通过 Git 推送。评论区的\u0026quot;登陆\u0026quot;，实际上是授权 Giscus 使用读者的 GitHub 账号，与你的网站本身无关。\n安全： 静态博客极其安全！这是它最爽的地方。黑客们常攻击的是网站的数据库、后台漏洞、服务器程序。而你的网站只是一堆静态文件，没有任何程序可以攻击。黑客无法\u0026quot;黑进\u0026quot;你的网站，因为根本\u0026quot;无门可入\u0026quot;。你的安全由 GitHub 这样的大公司保障，远比自己维护一台服务器要安全得多。\n隐私： 你的网站本身不收集任何访客信息。但你集成的第三方服务（比如 Giscus）有它们自己的隐私策略。这是一个很好的习惯：可以在博客上创建一个\u0026quot;关于\u0026quot;页面或\u0026quot;隐私\u0026quot;页面，简单说明你使用了 Giscus 进行评论，并链接到 GitHub 的隐私政策。\n结语 最后用一句信达雅的名人名言结语：\nTalk is cheap,show me the code.(废话少说，放码过来。) \u0026ndash;Linus Torvalds\n我们可以发现：只要根据报错的代码，一步步走下来，计算机确实就没有什么“黑魔法”，而你就是甘道夫。\nNow,it\u0026rsquo;s your turn.\n","permalink":"https://QwQBiG.github.io/posts/hello-world/","summary":"\u003cp\u003e你好，世界！\u003c/p\u003e\n\u003cp\u003e多年之后，看到这些文字，如今的你，是否还会想起，多年前看b站视频打印“hello world!”的那个遥远的下午\u0026hellip;\u003c/p\u003e\n\u003cp\u003e如果你能看到这篇文章，那说明我成功了。作为一只冲浪老资历，我一直梦想拥有一个属于自己的、可以记录学习笔记、分享心得的个人博客（东方homo馆）。这便是我的“Hello World”——一个通往更广阔数字世界的起点。（兴许是“读瘾”犯了，要写点东西自己咂摸）\u003c/p\u003e\n\u003cp\u003e溯洄从之，道阻且长。如同伊人，此间追寻的过程远比我想象的要曲折，但也比我想象的要收获更多。我遇到了各种各样的问题：从 Docker 的内网穿透失败（其实成功了（但是https）），到 Windows 开发环境的重重陷阱，再到网络连接的神秘莫测，最后到项目结构的频频阻折\u0026hellip;\u003c/p\u003e\n\u003cp\u003e所幸“时来天地皆同力”，假借实验室老老资历学长给的焚诀（代理，ai，服务器的一块ubuntu\u0026hellip;）得以为今后的所有故事作一个序。\u003c/p\u003e\n\u003cp\u003e而我的感觉是：尽管ai飞速发展，博客、论坛、群聊比比皆是，我自己搜寻资料时，找相应操作时，或者找一些有的没有的奇怪资源时，还是有些力不从心（主要是豆沙包和臭鲸鱼现在确实一般般（25.11））；加上我喜欢鼓捣些长久的、有趣的、有意味（意味深）的东西，顾影自怜，自我怀念，比如写诗著文，都是些艺术形式，于是便有了这个界面的出现。\u003c/p\u003e\n\u003cp\u003e谁不想要一个自己的文章网站呢~\u003c/p\u003e\n\u003cp\u003e现在，我想把这条被我“踩”出来的、不怕ta“爱而不见”的路，分享给你。\u003c/p\u003e","title":"史诗级“Hello World”：如何从0到1（划掉）搭建个人技博（技术博客）"}]