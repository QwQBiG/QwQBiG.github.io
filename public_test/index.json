[{"content":"🚀 编程语言速通指南：C/C++ 选手的多宇宙生存手册 适用人群：已掌握 C，进修 C++ 辅修 Py，被迫学 Java/JS，想搞 Rust 的大一/大二学生。\n核心心法：语言只是工具，设计哲学才是灵魂。不要背语法，要懂“为什么这么设计”。\n🗺️ 第一章：总览 —— 四角恋 在开始具体语言之前，先建立坐标系。\n特性维度 🛡️ C++ (主修) ☕ Java (学校的作业) 🌐 JavaScript (Web必修) 🦀 Rust (加入蟹教！) 内存管理 手动/RAII\n(自由但危险) GC 垃圾回收\n(省心但不可控) GC 垃圾回收\n(完全黑盒) 所有权 (Ownership)\n(编译期强制管理) 类型系统 静态强类型\n(但也允许指针瞎转) 静态强类型\n(泛型是擦除法做的) 动态弱类型\n(变量类型随时变) 静态极强类型\n(几乎零隐式转换) 核心哲学 零开销抽象\n(相信程序员) 工程安全性\n(防住菜鸟程序员) 灵活与交互\n(先跑起来再说) 安全与性能并存\n(编译器是你爹) 运行机制 编译 -\u0026gt; 机器码 编译 -\u0026gt; 字节码 -\u0026gt; JVM 源码 -\u0026gt; V8引擎 -\u0026gt; 解释/JIT 编译 -\u0026gt; 机器码 (LLVM) ☕ 第二章：Java —— “被阉割且穿上防弹衣的 C++” 💡 速通注解：把 Java 当作一个没有指针、强制面向对象、自带内存管家的 C++ 子集。\n1. 核心差异（必须扭转的 C++ 习惯） 一切皆引用（除了基本类型）：\nC++: Student a = b; (默认是值拷贝，a 和 b 是两块内存)。 Java: Student a = b; (永远是指针拷贝，a 和 b 指向同一个对象)。 ⚠️ 警告：在 LeetCode 里做回溯算法（Backtracking）时，往结果集里添加 List 时，必须 new ArrayList\u0026lt;\u0026gt;(currentList)，否则你最后存的全是同一个空列表的引用。\n没有析构函数 (Destructor)：\nC++: } 结束，栈对象自动销毁，释放资源（RAII）。 Java: 对象活着，内存由 GC 回收。文件/数据库连接必须用 try-with-resources 显式关闭。 真·面向对象：\n没有全局函数，连 main 都要包在 class 里。 没有头文件，只有 import。 2. LeetCode 刷题映射表 C++ (STL) Java (Collection Framework) 备注 std::vector\u0026lt;int\u0026gt; ArrayList\u0026lt;Integer\u0026gt; Java 泛型不能存 int，只能存包装类 Integer std::string String / StringBuilder ⚠️ Java String 不可变！频繁拼接必须用 StringBuilder std::map HashMap / TreeMap HashMap 无序，TreeMap 有序(红黑树) std::stack Deque (ArrayDeque) Java 的 Stack 类太老了，官方推荐用 Deque 替代 pair\u0026lt;int,int\u0026gt; int[] 或 自定义类 Java 原生没有 Pair，通常用长度为2的数组代替 🌐 第三章：JavaScript —— “披着 C 外衣的 Lisp” 💡 速通注解：千万别被它的花括号骗了，它和 C/Java 只有长得像。它的灵魂是 异步 和 函数式。\n1. 核心差异（最容易翻车的坑） 单线程与事件循环 (Event Loop)：\n概念: C++ 睡觉（sleep）会卡死线程。JS 绝不允许卡死主线程（因为主线程要渲染网页）。 机制: 耗时任务（网络、定时器）会被扔给浏览器，完成后把回调函数扔进任务队列。 ⚠️ 重点：这就是为什么你会在 JS 里看到满屏幕的 Promise、async、await。这是 Web 开发的基石。 类型系统的放飞自我：\n\u0026quot;1\u0026quot; + 1 结果是 \u0026quot;11\u0026quot; (字符串拼接)。 \u0026quot;1\u0026quot; - 1 结果是 0 (数字减法)。 🛡️ 防御手段：永远使用 const (不可变变量) 和 let，绝对不要用 var。比较相等永远用 === (三等号)，绝对不要用 ==。 原型链 (Prototype)：\nJS 的 class 只是语法糖。本质上它是通过“克隆”一个对象并建立链接来实现继承的。 2. 学习策略 DOM 操作：学会 document.querySelector 怎么抓元素。 Fetch API：学会怎么发网络请求（这就不仅是语言了，涉及 HTTP 协议）。 🦀 第四章：Rust —— “为了解决 C++ 膈应人而生！” 💡 速通注解：孩子喜欢 Rust 是对的（）。它是未来的系统级语言。用 Rust 可以更好的提升 C++ 能力。\n1. 核心差异 所有权 (Ownership) vs 拷贝 (Copy)：\nC++: auto a = vector_data; (隐式深拷贝/拷贝构造，开销大)。 Rust: let a = vector_data; (默认是 Move 移动)。旧变量 vector_data 直接失效！编译器禁止你再访问它。 目的: 彻底杜绝 Double Free（重复释放）和 Use After Free（释放后使用）。 借用检查 (Borrow Checker) —— 你的新“敌人”：\n规则：同一时间，数据的引用，要么只能有一个可写的，要么可以有无数个只读的。绝不共存。 C++: 允许你在遍历 vector 的同时修改它（然后导致迭代器失效，程序崩溃）。 Rust: 编译时直接报错，逼你修改逻辑。 没有继承，只有组合：\nRust 抛弃了复杂的 class 继承树，改用 Trait (类似接口) 和 Struct 组合。这符合“多用组合，少用继承”的现代设计原则。 2. 避坑指南（针对初学者） 不要用 Rust 写链表！ （至少一开始不要qwq）。Rust 的所有权机制会让双向链表极其难写（需要 Unsafe 或 Rc\u0026lt;RefCell\u0026lt;\u0026gt;\u0026gt;），这会打击咱的自信心。先用 Rust 写写算法题、命令行工具（交叉编译玩板子也好）。\n⚔️ 第五章：实战演练 —— 茴字的四种写法 任务：创建一个对象，打印，然后传递给函数。\n1. C++ (Standard) 1 2 3 4 5 6 7 8 9 10 11 12 13 struct Person { string name; }; void printPerson(Person p) // ⚠️ 发生拷贝！(除非加 \u0026amp;) { cout \u0026lt;\u0026lt; p.name \u0026lt;\u0026lt; endl; } int main() { Person me = {\u0026#34;Alice\u0026#34;}; printPerson(me); // me 依然有效，只是被拷贝了一份 return 0; } 2. Java (Reference) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Person { String name; } // 必须在 class 里 class Main { static void printPerson(Person p) // ⚠️ 传的是引用的副本(指针) { System.out.println(p.name); } public static void main(String[] args) { Person me = new Person(); me.name = \u0026#34;Alice\u0026#34;; printPerson(me); // me 依然有效，指向同一个对象 } } 3. JavaScript (Dynamic) 1 2 3 4 5 6 7 8 9 10 // 对象字面量，不需要类 const me = { name: \u0026#34;Alice\u0026#34; }; function printPerson(p) { console.log(p.name); } printPerson(me); // 传引用 // ⚠️ 甚至可以动态加属性: me.age = 18; 4. Rust (Ownership) 1 2 3 4 5 6 7 8 9 10 11 12 13 struct Person { name: String } fn print_person(p: Person) { // ⚠️ 所有权发生转移 (Move)！ println!(\u0026#34;{}\u0026#34;, p.name); } // p 在这里被 drop (析构) fn main() { let me = Person { name: String::from(\u0026#34;Alice\u0026#34;) }; print_person(me); // println!(\u0026#34;{}\u0026#34;, me.name); // ❌ 报错！me 已经不能用了！ } 🎓 第六章：好的规划 (速通路线) 依旧，不要试图平均用力。精力有限。\nC++ (主力 - 60% 精力)\n目标：理解指针、内存、栈与堆。刷 LeetCode 主力语言。 收益：打下坚实的计算机科学基础。 Java \u0026amp; Web (技多不压身嘛 - 10% 精力)\n目标：面向绩点编程。 Java: 掌握 Class/Interface/Polymorphism (多态) 即可。 Web: 掌握 HTML结构 + CSS布局 + JS基础交互。 心态：应付得当。 Rust (⚪神启动 - 30% 精力)\n目标：面向未来编程。 做法：当你觉得 C++ 的指针让你头疼，或者 Segment Fault 让你崩溃时，去学 Rust。 收益：学会 Rust 会反过来让你成为一个更好的 C++ 程序员（你会下意识地写出更安全的代码）。 📝 最后 LeetCode 多语言刷题：这是一个极好的习惯。建议顺序：先写 C++ 版（想算法），再写 Java/JS 版（练 API），最后尝试 Rust 版（如果你能用 Rust 写出来，说明你对内存掌控已经无敌了）。 ","permalink":"https://QwQBiG.github.io/posts/siguoyuyan/","summary":"\u003ch1 id=\"-编程语言速通指南cc-选手的多宇宙生存手册\"\u003e🚀 编程语言速通指南：C/C++ 选手的多宇宙生存手册\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e适用人群\u003c/strong\u003e：已掌握 C，进修 C++ 辅修 Py，被迫学 Java/JS，想搞 Rust 的大一/大二学生。\u003cbr\u003e\n\u003cstrong\u003e核心心法\u003c/strong\u003e：语言只是工具，设计哲学才是灵魂。不要背语法，要懂“为什么这么设计”。\u003c/p\u003e\n\u003ch2 id=\"-第一章总览--四角恋\"\u003e🗺️ 第一章：总览 —— 四角恋\u003c/h2\u003e\n\u003cp\u003e在开始具体语言之前，先建立坐标系。\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e特性维度\u003c/th\u003e\n          \u003cth\u003e🛡️ C++ (主修)\u003c/th\u003e\n          \u003cth\u003e☕ Java (学校的作业)\u003c/th\u003e\n          \u003cth\u003e🌐 JavaScript (Web必修)\u003c/th\u003e\n          \u003cth\u003e🦀 Rust (加入蟹教！)\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e内存管理\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e手动/RAII\u003cbr\u003e(自由但危险)\u003c/td\u003e\n          \u003ctd\u003eGC 垃圾回收\u003cbr\u003e(省心但不可控)\u003c/td\u003e\n          \u003ctd\u003eGC 垃圾回收\u003cbr\u003e(完全黑盒)\u003c/td\u003e\n          \u003ctd\u003e所有权 (Ownership)\u003cbr\u003e(编译期强制管理)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e类型系统\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e静态强类型\u003cbr\u003e(但也允许指针瞎转)\u003c/td\u003e\n          \u003ctd\u003e静态强类型\u003cbr\u003e(泛型是擦除法做的)\u003c/td\u003e\n          \u003ctd\u003e动态弱类型\u003cbr\u003e(变量类型随时变)\u003c/td\u003e\n          \u003ctd\u003e静态极强类型\u003cbr\u003e(几乎零隐式转换)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e核心哲学\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e零开销抽象\u003cbr\u003e(相信程序员)\u003c/td\u003e\n          \u003ctd\u003e工程安全性\u003cbr\u003e(防住菜鸟程序员)\u003c/td\u003e\n          \u003ctd\u003e灵活与交互\u003cbr\u003e(先跑起来再说)\u003c/td\u003e\n          \u003ctd\u003e安全与性能并存\u003cbr\u003e(编译器是你爹)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e运行机制\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e编译 -\u0026gt; 机器码\u003c/td\u003e\n          \u003ctd\u003e编译 -\u0026gt; 字节码 -\u0026gt; JVM\u003c/td\u003e\n          \u003ctd\u003e源码 -\u0026gt; V8引擎 -\u0026gt; 解释/JIT\u003c/td\u003e\n          \u003ctd\u003e编译 -\u0026gt; 机器码 (LLVM)\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"-第二章java--被阉割且穿上防弹衣的-c\"\u003e☕ 第二章：Java —— “被阉割且穿上防弹衣的 C++”\u003c/h2\u003e\n\u003cp\u003e💡 \u003cstrong\u003e速通注解\u003c/strong\u003e：把 Java 当作一个没有指针、强制面向对象、自带内存管家的 C++ 子集。\u003c/p\u003e","title":"C/C++速通Java?JS?Rust?"},{"content":"别看，我还没有施工呢！\n文章列表 第一篇：STL 容器\n简介：人如其名\n第二篇：STL 算法\n简介：+1\n第三篇：范围for循环\n简介：全面的范围for循环！！！\n","permalink":"https://QwQBiG.github.io/series/taoke/","summary":"\u003cp\u003e别看，我还没有施工呢！\u003c/p\u003e\n\u003ch2 id=\"文章列表\"\u003e文章列表\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e第一篇：\u003ca href=\"../../posts/stlcontainer/\"\u003eSTL 容器\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e简介：人如其名\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e第二篇：\u003ca href=\"../../posts/stlalgorithm/\"\u003eSTL 算法\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e简介：+1\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e第三篇：\u003ca href=\"../../fanweiforxunhuan/\"\u003e范围for循环\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e简介：全面的范围for循环！！！\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"逃课-速通"},{"content":" 2026 寒假 任务04 “启动：硬起来的臭企鹅”\n🦊 Luckfox Pico Mini B (RV1103) 嵌入式开发笔记 目标：从零开始搭建嵌入式 Linux + AI 环境\n硬件：Luckfox Pico Mini B (RV1103) + SC3336 摄像头\n达成：✅ 系统烧录 | ✅ 驱动排查 | ✅ SSH 连接 (ADB 隧道方案)\n要跟着官方文档来玩~\n🛠️ 第一章：系统镜像与烧录 Luckfox Pico Mini B 支持两种启动方式：TF 卡启动 (MicroSD) 和 板载闪存启动 (SPI NAND Flash)。\n启动优先级：TF 卡 \u0026gt; 板载 Flash。只要插了 TF 卡，板子就会优先读卡。\n1. 烧录板载 Flash (使用 SocToolKit) 适用场景：不插 TF 卡时运行的基础系统。\n工具：SocToolKit (瑞芯微官方工具)。\n操作要点：\n按住 BOOT 键连接电脑进入 MaskRom 模式。 选择 Download 模式。 选择对应的分区文件烧录。 经验：我们这一步操作是正确的。虽然我们主要用 TF 卡，但刷好 Flash 作为备用系统（救砖用）是个好习惯。\n2. 烧录 TF 卡 (推荐) 适用场景：跑 Ubuntu、运行大型 AI 模型（Flash 空间不够）。\n关键误区修正：\n❌ 错误：把 TF 卡插在板子上，再把板子插电脑（电脑把板子当成 USB 设备，读不到卡）。 ✅ 正确：必须使用 USB 读卡器连接 TF 卡到电脑。 镜像选择：文件名包含 Mini_B、MicroSD、Ubuntu (或 Buildroot)。\n工具推荐：Win32DiskImager (比 SocToolKit 的 SD 模式更简单稳定)。\n操作：\n打开 Win32DiskImager。 选择 .img 镜像。 选择读卡器盘符 -\u0026gt; Write。 🚧 第二章：RNDIS 驱动之战 (Code 56) 这是最艰难的环节。当我们试图通过 USB 虚拟网卡 (RNDIS) 连接板子时，遭遇了 Windows 的顽疾。\n1. 问题现象 设备管理器中显示 基于远程 NDIS 的 Internet 共享设备。 状态栏有黄色感叹号。 报错信息：“Windows 仍在设置此设备的类配置 (代码 56)”。 2. 根本原因 软件冲突：电脑上安装的 蒲公英 VPN (OrayBox)、UU 加速器、VMware 等软件安装了底层的“网络过滤驱动”。\n当 RNDIS 网卡尝试初始化时，这些过滤驱动会拦截并导致冲突，Windows 无法完成配置。\n3. 尝试过的方案（避大坑） ❌ 方案 A：网络重置（极度危险，会导致网卡掉驱动，且不一定能修好（一定不~））。 ⚠️ 方案 B：手动更新驱动（选 Microsoft -\u0026gt; 远程 NDIS 兼容设备）。这对普通感叹号有效，但对 Code 56 无效。 ✅ 方案 C：卸载冲突软件。卸载蒲公英/UU 后，驱动立刻恢复正常。（不一定，不建议） 🚀 第三章：绝处逢生 —— ADB 隧道方案 在 RNDIS 驱动无法使用（或不愿卸载 VPN）的情况下，我们找到了不需要网卡的终极替代方案。\n1. 核心逻辑 ADB (Android Debug Bridge)：瑞芯微芯片支持 ADB 调试。\n优势：ADB 走的是调试通道，不经过网络协议栈，所以完全不受蒲公英/UU/防火墙的影响。\n2. 操作步骤 Step 1: 确认连接\n在 Windows PowerShell / CMD 中：\n1 2 adb devices # 输出: xxxxx device (表示已连接) Step 2: 端口映射 这是让 SSH 跑在 USB 线上的关键命令：\n1 adb forward tcp:2222 tcp:22 含义：把电脑的 2222 端口映射到板子的 22 (SSH) 端口。\nStep 3: SSH 连接 使用 MobaXterm 或 PowerShell 连接：(Tabby~)\n主机 (Host): 127.0.0.1 (本地回环地址) 端口 (Port): 2222 (映射后的端口) 用户: pico 密码: luckfox 命令版：\n1 ssh pico@127.0.0.1 -p 2222 3. 文件传输 既然没有网卡，就不能用 SCP。改用 ADB 传输：\n电脑 -\u0026gt; 板子: adb push 本地文件 /pico/ 板子 -\u0026gt; 电脑: adb pull /pico/照片.jpg 本地路径 🔮 第四章：未来的开发模式 至此，我们的环境已经通了。接下来的 Task 7-9 (C++ 开发与 AI 部署) 将遵循以下\u0026quot;离线开发模式\u0026quot;：\n开发与编译：\n在 PC (Ubuntu/WSL) 上写 C++ 代码。 使用交叉编译工具链生成可执行文件。 传输：\n通过 adb push 将可执行文件扔进板子。 运行：\n通过 ssh -p 2222 进入板子终端。 执行程序 (./my_program)。 调试：\n板子负责跑，结果通过终端回显，图片通过 adb pull 拉回来看。 总结：绕过了 Windows 复杂的网络驱动地狱，利用 ADB 强行打通了控制隧道。虽然板子本身没网，但对于嵌入式 AI 开发来说，只要能传文件、能敲命令，就足够了！(吧)\n","permalink":"https://QwQBiG.github.io/posts/q26han04/","summary":"\u003cblockquote\u003e\n\u003cp\u003e2026 寒假 任务04 “启动：硬起来的臭企鹅”\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch1 id=\"-luckfox-pico-mini-b-rv1103-嵌入式开发笔记\"\u003e🦊 Luckfox Pico Mini B (RV1103) 嵌入式开发笔记\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e目标\u003c/strong\u003e：从零开始搭建嵌入式 Linux + AI 环境\u003cbr\u003e\n\u003cstrong\u003e硬件\u003c/strong\u003e：Luckfox Pico Mini B (RV1103) + SC3336 摄像头\u003cbr\u003e\n\u003cstrong\u003e达成\u003c/strong\u003e：✅ 系统烧录 | ✅ 驱动排查 | ✅ SSH 连接 (ADB 隧道方案)\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e要跟着官方文档来玩~\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"-第一章系统镜像与烧录\"\u003e🛠️ 第一章：系统镜像与烧录\u003c/h2\u003e\n\u003cp\u003eLuckfox Pico Mini B 支持两种启动方式：\u003cstrong\u003eTF 卡启动 (MicroSD)\u003c/strong\u003e 和 \u003cstrong\u003e板载闪存启动 (SPI NAND Flash)\u003c/strong\u003e。\u003cbr\u003e\n\u003cstrong\u003e启动优先级\u003c/strong\u003e：TF 卡 \u0026gt; 板载 Flash。只要插了 TF 卡，板子就会优先读卡。\u003c/p\u003e\n\u003ch3 id=\"1-烧录板载-flash-使用-soctoolkit\"\u003e1. 烧录板载 Flash (使用 SocToolKit)\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e适用场景\u003c/strong\u003e：不插 TF 卡时运行的基础系统。\u003cbr\u003e\n\u003cstrong\u003e工具\u003c/strong\u003e：SocToolKit (瑞芯微官方工具)。\u003cbr\u003e\n\u003cstrong\u003e操作要点\u003c/strong\u003e：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e按住 BOOT 键连接电脑进入 MaskRom 模式。\u003c/li\u003e\n\u003cli\u003e选择 Download 模式。\u003c/li\u003e\n\u003cli\u003e选择对应的分区文件烧录。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e经验\u003c/strong\u003e：我们这一步操作是正确的。虽然我们主要用 TF 卡，但刷好 Flash 作为备用系统（救砖用）是个好习惯。\u003c/p\u003e","title":"LuckFox RV1103 板子烧录开机登录~"},{"content":" 2026 寒假 任务03 “刷机，让14年的平板重获新生。”\n📝 Samsung Galaxy Tab Pro 8.4 (SM-T320) 刷机改造日志 目标：将 2014 年的老平板改造为基于 Android 13 的便携式 Linux/C++ 开发终端。\n硬件：Samsung SM-T320 (骁龙800 / 2GB RAM / 2K屏幕)\n🛠️ 第一阶段：刷机 (Flashing) 1. 准备工作 电脑端：\n安装三星 USB 驱动 (SAMSUNG_USB_Driver...exe)。 解压 Odin3_v3.14.1.zip。 文件准备：\nRecovery: twrp-3.7.0_9-0-mondrianwifi.img.tar ROM: lineage-20.0-xxxx-UNOFFICIAL-mondrianwifi.zip (Android 13) GApps: BiTGApps-arm-13.0.0-v1.7_signed.zip (我是 ARM 架构) 2. 刷入 TWRP 进挖煤模式：\n关机状态下，按 音量减 + Home + 电源，出现警告按 音量加。 Odin 设置：\n点击 AP，选择 twrp...tar 文件。 关键：左侧 Options 栏 取消勾选 Auto Reboot。 点击 Start，等待显示 PASS。 强制进 TWRP：\n按 电源 + 音量减 强制重启。 黑屏瞬间，立刻改按 电源 + Home + 音量加。 出 Logo 松开电源，死按住 Home + 音量加 直到进入 TWRP。 3. 刷入系统 (ROM) 双清 (Wipe)：\nWipe -\u0026gt; Advanced Wipe -\u0026gt; 勾选 Dalvik, Cache, System, Data -\u0026gt; 滑动清除。 传文件：\n保持 TWRP 界面，插线连电脑，将 ROM 和 GApps 两个 zip 包复制进平板根目录。 安装 (Install)：\nInstall -\u0026gt; 选中 ROM 包 -\u0026gt; (Add more Zips 选 GApps 包) -\u0026gt; 滑动刷入。 刷完后点击 Reboot System。 注：若 Android 13 报错，可改刷 Android 11 (LineageOS 18.1)。\n🚀 第二阶段：系统优化 (Optimization) 开发者设置：\n设置 -\u0026gt; 关于平板 -\u0026gt; 版本号连点 7 次。 系统 -\u0026gt; 开发者选项 -\u0026gt; 窗口/过渡/动画时长缩放 全部改为 0.5x (极大提升流畅度)。 APP 准备：\n安装 F-Droid (开源商店)。 通过 F-Droid 安装 Termux (勿用 Google Play 版)。 💻 第三阶段：构建开发环境 (Termux \u0026amp; Zsh) 1. 基础环境配置 打开 Termux 执行：\n1 2 3 termux-change-repo # 选清华源 (TUNA) pkg update -y \u0026amp;\u0026amp; pkg upgrade -y pkg install clang make vim git openssh -y # 安装 C++/SSH 工具链 2. Zsh 美化 (Oh-My-Zsh) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 1. 安装 Zsh 和 Oh-My-Zsh pkg install zsh sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; # 2. 安装高亮和补全插件 git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions # 3. 编辑配置 nano ~/.zshrc # 修改: ZSH_THEME=\u0026#34;ys\u0026#34; # 修改: plugins=(git zsh-syntax-highlighting zsh-autosuggestions) # 4. 生效 source ~/.zshrc 🔗 第四阶段：硬件联动 (Luckfox Pico) 场景：平板通过 USB OTG 连接 Luckfox Pico 开发板，进行 SSH 开发。\n物理连接：平板 -\u0026gt; OTG -\u0026gt; Type-C -\u0026gt; Luckfox。\n网络确认：Termux 输入 ifconfig 确认有 eth0 或 usb0 网卡。\n快捷连接： 在 ~/.zshrc 底部添加：\n1 alias pico=\u0026#39;ssh root@172.32.0.93\u0026#39; 使用： 终端输入 pico -\u0026gt; 密码 luckfox -\u0026gt; 成功进入板子 Linux 系统。\n🎉 最终成果 Android 13 纯净系统。 0.5x 动画倍率的流畅体验。 Zsh + 插件 的全功能终端。 C++ 编译环境 (Clang)。 一键连接嵌入式开发板的能力。 ","permalink":"https://QwQBiG.github.io/posts/q26han03/","summary":"\u003cblockquote\u003e\n\u003cp\u003e2026 寒假 任务03 “刷机，让14年的平板重获新生。”\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch1 id=\"-samsung-galaxy-tab-pro-84-sm-t320-刷机改造日志\"\u003e📝 Samsung Galaxy Tab Pro 8.4 (SM-T320) 刷机改造日志\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e目标\u003c/strong\u003e：将 2014 年的老平板改造为基于 Android 13 的便携式 Linux/C++ 开发终端。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e硬件\u003c/strong\u003e：Samsung SM-T320 (骁龙800 / 2GB RAM / 2K屏幕)\u003c/p\u003e\n\u003ch2 id=\"-第一阶段刷机-flashing\"\u003e🛠️ 第一阶段：刷机 (Flashing)\u003c/h2\u003e\n\u003ch3 id=\"1-准备工作\"\u003e1. 准备工作\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e电脑端\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e安装三星 USB 驱动 (\u003ccode\u003eSAMSUNG_USB_Driver...exe\u003c/code\u003e)。\u003c/li\u003e\n\u003cli\u003e解压 \u003ccode\u003eOdin3_v3.14.1.zip\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e文件准备\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eRecovery\u003c/strong\u003e: \u003ccode\u003etwrp-3.7.0_9-0-mondrianwifi.img.tar\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eROM\u003c/strong\u003e: \u003ccode\u003elineage-20.0-xxxx-UNOFFICIAL-mondrianwifi.zip\u003c/code\u003e (Android 13)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGApps\u003c/strong\u003e: \u003ccode\u003eBiTGApps-arm-13.0.0-v1.7_signed.zip\u003c/code\u003e (我是 \u003cstrong\u003eARM\u003c/strong\u003e 架构)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"2-刷入-twrp\"\u003e2. 刷入 TWRP\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e进挖煤模式\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e关机状态下，按 \u003cstrong\u003e音量减 + Home + 电源\u003c/strong\u003e，出现警告按 \u003cstrong\u003e音量加\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eOdin 设置\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e点击 \u003cstrong\u003eAP\u003c/strong\u003e，选择 \u003ccode\u003etwrp...tar\u003c/code\u003e 文件。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e关键\u003c/strong\u003e：左侧 \u003cstrong\u003eOptions\u003c/strong\u003e 栏 \u003cstrong\u003e取消勾选\u003c/strong\u003e Auto Reboot。\u003c/li\u003e\n\u003cli\u003e点击 \u003cstrong\u003eStart\u003c/strong\u003e，等待显示 \u003cstrong\u003ePASS\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e强制进 TWRP\u003c/strong\u003e：\u003c/p\u003e","title":"三星平板刷机"},{"content":" 2026 寒假 任务02 “我想用 ESP32 做一个 Web 服务器。用 C++ 代码： 让 ESP32 使用 AP 模式（Access Point）启动一个 Web Server，当手机访问 ESP32 的 IP 地址时，显示两个按钮 \u0026ldquo;ON\u0026rdquo; 和 \u0026ldquo;OFF\u0026rdquo;。点击按钮可以通过 GPIO 控制面包板上外接的 LED 灯（假设接在 GPIO 23）。”\n方案思路：ESP32 自己做“路由器” 在这个模式下，ESP32 不去连接自己家里的 WiFi，而是它自己发射一个 WiFi 热点。\n手机搜索并连接 ESP32 发出的 WiFi。 连接后，直接访问 ESP32 的地址控制灯光。 优点：这样我们走到哪里都能演示，完全不需要依赖环境的 WiFi。\n第一部分：接线与“如何让它好看” “感觉不好看”，通常是因为面包板上的杜邦线飞来飞去乱糟糟的。\n1. 极简方案（最“好看”） 直接使用板载 LED（GPIO 2）。\nESP32 开发板上自带了一颗蓝灯，通常连接在 GPIO 2。 你可以完全不接外面的线，代码里把 LED_PIN 改成 2，直接看板子上的灯亮灭，最整洁。 2. 外接 LED 优化方案（让面包板接线整齐） 如果你必须外接 LED（假设 GPIO 23），可以尝试**“紧凑型”接法**，避免使用很长的飞线。\n电路逻辑： GPIO 23 \u0026ndash;\u0026gt; LED 正极 (长脚) \u0026ndash;\u0026gt; LED \u0026ndash;\u0026gt; LED 负极 (短脚) \u0026ndash;\u0026gt; 电阻 \u0026ndash;\u0026gt; GND\n实物插法建议（以此顺序插在面包板上）：\nLED：跨插在面包板的两排孔上（比如长脚插 e10，短脚插 e11）。 电阻：一端插在 a11 (对应 LED 短脚)，另一端插在 GND 所在的蓝色电源导轨上（如果电阻脚够长，直接跨过去，不用线）。 跳线：只需要一根短线，从 ESP32 的 D23 插到 a10 (对应 LED 长脚)。 这样在这个小区域内就形成了一个回路，线尽可能短，看起来会专业很多。\n第二部分：AP 模式代码 请将 src/main.cpp 的内容替换为以下代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 #include \u0026lt;Arduino.h\u0026gt; #include \u0026lt;WiFi.h\u0026gt; #include \u0026lt;WebServer.h\u0026gt; // ================= 配置区域 ================= // 这次我们设置 ESP32 自己发出的 WiFi 名字和密码 const char* ap_ssid = \u0026#34;My_ESP32_Control\u0026#34;; // 手机搜到的 WiFi 名字 const char* ap_password = \u0026#34;12345678\u0026#34;; // 连接这个 WiFi 的密码（至少8位） // 选择 LED 引脚 // 如果想最整洁，用板载 LED (通常是 2)，如果外接用了 23 就写 23 #define LED_PIN 2 // =========================================== WebServer server(80); // HTML 页面代码（保持不变） String getHTML() { String html = R\u0026#34;rawliteral( \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34;\u0026gt; \u0026lt;title\u0026gt;ESP32 控制台\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { font-family: Helvetica; text-align: center; margin-top: 50px; background-color: #f0f0f0;} h1 { color: #333; } .btn { display: inline-block; padding: 20px 40px; font-size: 30px; color: white; text-decoration: none; border-radius: 10px; margin: 20px; box-shadow: 2px 2px 5px rgba(0,0,0,0.3); } .on { background-color: #4CAF50; } .off { background-color: #f44336; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;💡 灯光控制中心\u0026lt;/h1\u0026gt; \u0026lt;a href=\u0026#34;/on\u0026#34; class=\u0026#34;btn on\u0026#34;\u0026gt;开启 ON\u0026lt;/a\u0026gt; \u0026lt;br\u0026gt; \u0026lt;a href=\u0026#34;/off\u0026#34; class=\u0026#34;btn off\u0026#34;\u0026gt;关闭 OFF\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; )rawliteral\u0026#34;; return html; } void handleRoot() { server.send(200, \u0026#34;text/html\u0026#34;, getHTML()); } void handleLedOn() { digitalWrite(LED_PIN, HIGH); Serial.println(\u0026#34;LED ON\u0026#34;); server.send(200, \u0026#34;text/html\u0026#34;, getHTML()); } void handleLedOff() { digitalWrite(LED_PIN, LOW); Serial.println(\u0026#34;LED OFF\u0026#34;); server.send(200, \u0026#34;text/html\u0026#34;, getHTML()); } void setup() { Serial.begin(115200); pinMode(LED_PIN, OUTPUT); digitalWrite(LED_PIN, LOW); // === 核心变化：启动 AP 模式 === Serial.println(\u0026#34;\\n正在启动 AP 模式...\u0026#34;); // 设置 ESP32 为 AP 模式 WiFi.softAP(ap_ssid, ap_password); // 获取 ESP32 自己的 IP 地址（AP 模式下通常默认是 192.168.4.1） IPAddress IP = WiFi.softAPIP(); Serial.print(\u0026#34;AP 启动成功! WiFi 名称: \u0026#34;); Serial.println(ap_ssid); Serial.print(\u0026#34;请手机连接该 WiFi，然后访问: http://\u0026#34;); Serial.println(IP); server.on(\u0026#34;/\u0026#34;, handleRoot); server.on(\u0026#34;/on\u0026#34;, handleLedOn); server.on(\u0026#34;/off\u0026#34;, handleLedOff); server.begin(); } void loop() { server.handleClient(); } 第三步：如何操作 1. 烧录代码 构建完点击 VS Code 底部的 右箭头图标 (→) 进行烧录。\n2. 手机操作 打开手机的 设置 → 无线局域网 (Wi-Fi)。 在列表里查找 My_ESP32_Control（或者你自己设定的热点名称）。 输入密码 12345678 进行连接。 注意：手机可能会提示“该网络无法连接互联网”，这是正常的，选择“保持连接”即可。\n3. 控制设备 打开手机浏览器。 在地址栏输入 192.168.4.1（这是 ESP32 在 AP 模式下的默认固定地址）。 你将会看到一个 Web 控制页面，点击页面上的按钮即可远程控制灯光！ ","permalink":"https://QwQBiG.github.io/posts/q26han02/","summary":"\u003cblockquote\u003e\n\u003cp\u003e2026 寒假 任务02 “我想用 ESP32 做一个 Web 服务器。用 C++ 代码：\n让 ESP32 使用 AP 模式（Access Point）启动一个 Web Server，当手机访问 ESP32 的 IP 地址时，显示两个按钮 \u0026ldquo;ON\u0026rdquo; 和 \u0026ldquo;OFF\u0026rdquo;。点击按钮可以通过 GPIO 控制面包板上外接的 LED 灯（假设接在 GPIO 23）。”\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2 id=\"方案思路esp32-自己做路由器\"\u003e方案思路：ESP32 自己做“路由器”\u003c/h2\u003e\n\u003cp\u003e在这个模式下，ESP32 不去连接自己家里的 WiFi，而是它自己发射一个 WiFi 热点。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e手机搜索并连接 ESP32 发出的 WiFi。\u003c/li\u003e\n\u003cli\u003e连接后，直接访问 ESP32 的地址控制灯光。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e优点\u003c/strong\u003e：这样我们走到哪里都能演示，完全不需要依赖环境的 WiFi。\u003c/p\u003e\n\u003ch2 id=\"第一部分接线与如何让它好看\"\u003e第一部分：接线与“如何让它好看”\u003c/h2\u003e\n\u003cp\u003e“感觉不好看”，通常是因为面包板上的杜邦线飞来飞去乱糟糟的。\u003c/p\u003e\n\u003ch3 id=\"1-极简方案最好看\"\u003e1. 极简方案（最“好看”）\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e直接使用板载 LED（GPIO 2）。\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eESP32 开发板上自带了一颗蓝灯，通常连接在 GPIO 2。\u003c/li\u003e\n\u003cli\u003e你可以完全不接外面的线，代码里把 LED_PIN 改成 2，直接看板子上的灯亮灭，最整洁。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"2-外接-led-优化方案让面包板接线整齐\"\u003e2. 外接 LED 优化方案（让面包板接线整齐）\u003c/h3\u003e\n\u003cp\u003e如果你必须外接 LED（假设 GPIO 23），可以尝试**“紧凑型”接法**，避免使用很长的飞线。\u003c/p\u003e","title":"ESP-32 Web 端远控点灯"},{"content":" 2026 寒假 任务01 “我现在手头有 ESP32-WROOM-32 开发板，使用 VS Code。请教我安装 PlatformIO 插件，并创建一个 Arduino 框架的 C++ 项目。给我一段简单的 Blink 代码，解释 setup() 和 loop() 的作用，并告诉我如何将代码烧录进板子。”\n第一步：安装 PlatformIO 插件 打开 VS Code。 点击左侧边栏的 扩展图标 (Extensions)，或按下快捷键 Ctrl+Shift+X。 在搜索框中输入 PlatformIO IDE。 选择由 PlatformIO 发布的插件（图标为蚂蚁头像），点击 Install。 注意：安装完成后，右下角通常会提示“Installing PlatformIO Core\u0026hellip;”。请耐心等待其安装完成并提示“Reload”（重启 VS Code）。此过程可能需要几分钟。 第二步：创建新项目 插件安装成功后，VS Code 左侧边栏会出现一个 PlatformIO 图标（蚂蚁）。点击它。 在打开的 PlatformIO 主页中，点击 New Project 按钮。 配置新项目： Name：输入项目名称，例如 ESP32_Blink（建议不要使用中文或空格）。 Board：在搜索框输入 DOIT ESP32，通常选择 DOIT ESP32 DEVKIT V1。这是 ESP32-WROOM-32 最常见的通用配置。 Framework：选择 Arduino。 点击 Finish。 首次创建项目时，PlatformIO 会自动下载 ESP32 的编译工具链和库文件。请保持网络通畅，耐心等待下载完成。 第三步：编写 Blink 代码 项目创建后，在 VS Code 的资源管理器（Explorer）中：\n展开项目文件夹。 进入 src 文件夹。 打开 main.cpp 文件（这是主程序文件）。 删除文件中的默认内容，粘贴以下代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;Arduino.h\u0026gt; // ESP32 开发板的板载 LED 通常连接在 GPIO 2。 // 如果你的板子不亮，请查阅具体板子的原理图（可能连接在引脚 1 或其他引脚）。 #define LED_PIN 2 // setup() 函数：初始化设置 // 此函数在板子上电或复位后，仅运行一次。 void setup() { // 将 LED 引脚设置为输出模式，以便控制其电平高低。 pinMode(LED_PIN, OUTPUT); } // loop() 函数：主循环 // setup() 执行完毕后，程序会不断重复执行此函数内的代码。 void loop() { digitalWrite(LED_PIN, HIGH); // 输出高电平，点亮 LED delay(1000); // 等待 1000 毫秒（1秒） digitalWrite(LED_PIN, LOW); // 输出低电平，熄灭 LED delay(1000); // 等待 1000 毫秒（1秒） } 代码原理解释 setup()：如同程序的“准备工作阶段”。仅在开始时执行一次，用于配置硬件初始状态。例如，本示例中我们初始化 GPIO 2 为输出模式。\nloop()：程序的主循环。在 setup() 完成后，会永远循环执行其中的代码。本示例中，它实现了 LED 亮灭的交替循环。\n第四步：编译与烧录（上传） 硬件连接 使用 USB 数据线将 ESP32 开发板连接到电脑。 连接检查：确保电脑已安装正确的 USB 转串口驱动（如 CP210x 或 CH340）。如果电脑无法识别设备，请前往制造商官网下载并安装对应驱动。 在 PlatformIO 中操作 PlatformIO 的主要操作按钮位于 VS Code 窗口底部的蓝色/紫色状态栏。\n编译：点击状态栏上的 对号图标 (✓)（或称为 Build）。此操作会检查代码语法并编译生成可执行文件。终端窗口显示 SUCCESS 表示编译成功。 烧录（上传）：点击状态栏上的 右箭头图标 (→)（或称为 Upload）。此操作会将编译好的程序上传（烧录）到 ESP32 开发板。 ⚠️ 常见问题：上传时卡在“Connecting\u0026hellip;” 点击上传后，如果终端长时间显示 Connecting........_____..... 且无进展：\n按住开发板上的 BOOT 按钮不放。 点击 VS Code 中的上传按钮。 等待终端出现“Writing”或“Downloading”等进度条开始走动的提示。 松开 BOOT 按钮。 注意：此操作是因为部分 ESP32 开发板需要手动进入下载模式。\n验证结果 当底部终端显示 [SUCCESS] 且进度条完成时，ESP32 开发板会自动复位并开始运行新程序。\n此时，您应该能看到开发板上的 板载 LED（通常是蓝色或红色） 开始以 1秒亮、1秒灭 的节奏持续闪烁。\n恭喜！我们已成功完成 ESP32 的“Hello World”项目。\n","permalink":"https://QwQBiG.github.io/posts/q26han01/","summary":"\u003cblockquote\u003e\n\u003cp\u003e2026 寒假 任务01 “我现在手头有 ESP32-WROOM-32 开发板，使用 VS Code。请教我安装 PlatformIO 插件，并创建一个 Arduino 框架的 C++ 项目。给我一段简单的 Blink 代码，解释 setup() 和 loop() 的作用，并告诉我如何将代码烧录进板子。”\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2 id=\"第一步安装-platformio-插件\"\u003e第一步：安装 PlatformIO 插件\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e打开 VS Code\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003e点击左侧边栏的 \u003cstrong\u003e扩展图标\u003c/strong\u003e (\u003ccode\u003eExtensions\u003c/code\u003e)，或按下快捷键 \u003ccode\u003eCtrl+Shift+X\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e在搜索框中输入 \u003cstrong\u003e\u003ccode\u003ePlatformIO IDE\u003c/code\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003e选择由 \u003cstrong\u003ePlatformIO\u003c/strong\u003e 发布的插件（图标为蚂蚁头像），点击 \u003cstrong\u003e\u003ccode\u003eInstall\u003c/code\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e注意\u003c/strong\u003e：安装完成后，右下角通常会提示“Installing PlatformIO Core\u0026hellip;”。请耐心等待其安装完成并提示“Reload”（重启 VS Code）。此过程可能需要几分钟。\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"第二步创建新项目\"\u003e第二步：创建新项目\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e插件安装成功后，VS Code 左侧边栏会出现一个 \u003cstrong\u003ePlatformIO 图标\u003c/strong\u003e（蚂蚁）。点击它。\u003c/li\u003e\n\u003cli\u003e在打开的 PlatformIO 主页中，点击 \u003cstrong\u003e\u003ccode\u003eNew Project\u003c/code\u003e\u003c/strong\u003e 按钮。\u003c/li\u003e\n\u003cli\u003e配置新项目：\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eName\u003c/strong\u003e：输入项目名称，例如 \u003ccode\u003eESP32_Blink\u003c/code\u003e（建议不要使用中文或空格）。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eBoard\u003c/strong\u003e：在搜索框输入 \u003ccode\u003eDOIT ESP32\u003c/code\u003e，通常选择 \u003cstrong\u003e\u003ccode\u003eDOIT ESP32 DEVKIT V1\u003c/code\u003e\u003c/strong\u003e。这是 ESP32-WROOM-32 最常见的通用配置。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eFramework\u003c/strong\u003e：选择 \u003cstrong\u003e\u003ccode\u003eArduino\u003c/code\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e点击 \u003cstrong\u003e\u003ccode\u003eFinish\u003c/code\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003e首次创建项目时，PlatformIO 会自动下载 ESP32 的编译工具链和库文件。请保持网络通畅，耐心等待下载完成。\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"第三步编写-blink-代码\"\u003e第三步：编写 Blink 代码\u003c/h2\u003e\n\u003cp\u003e项目创建后，在 VS Code 的资源管理器（Explorer）中：\u003c/p\u003e","title":"再一次梦开始的地方——ESP-32点灯"},{"content":"别看，我还没有施工呢！\n文章列表 第一篇：STL 容器\n简介：人如其名\n第二篇：STL 算法\n简介：+1\n第三篇：范围for循环\n简介：全面的范围for循环！！！\n","permalink":"https://QwQBiG.github.io/series/embedded/","summary":"\u003cp\u003e别看，我还没有施工呢！\u003c/p\u003e\n\u003ch2 id=\"文章列表\"\u003e文章列表\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e第一篇：\u003ca href=\"../../posts/stlcontainer/\"\u003eSTL 容器\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e简介：人如其名\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e第二篇：\u003ca href=\"../../posts/stlalgorithm/\"\u003eSTL 算法\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e简介：+1\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e第三篇：\u003ca href=\"../../fanweiforxunhuan/\"\u003e范围for循环\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e简介：全面的范围for循环！！！\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"成就-来硬的"},{"content":"C++ 范围 for 循环：从入门到精通的究极无敌炸裂雷霆笔记 一、 核心概念：告别索引，拥抱元素 基于范围的 for 循环（C++11 引入）是为了解决一个最常见的编程任务：遍历一个序列（如 vector, string）中的每一个元素。 它的核心思想是让你直接关注元素本身，而不用手动管理索引 i。\n基础语法:\n1 2 3 for ( declaration : range ) { // 循环体 } range: 你想要遍历的东西，比如一个 vector 或 string。 declaration: 一个变量声明，在每次循环时，range 中的一个元素会被赋值（或引用）给这个变量。 示例：告别传统 for 循环\n1 2 3 4 5 6 7 8 9 10 11 std::vector\u0026lt;int\u0026gt; nums = {10, 20, 30}; // 传统写法 (命令式：告诉计算机\u0026#34;如何做\u0026#34;) for (size_t i = 0; i \u0026lt; nums.size(); i++) { std::cout \u0026lt;\u0026lt; nums[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } // 范围 for 写法 (声明式：告诉计算机\u0026#34;想要什么\u0026#34;) for (int num : nums) { std::cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } 优点:\n简洁: 代码更短。 安全: 杜绝了因索引计算错误导致的越界 bug。 易读: for (int num : nums) 读起来就像自然语言：\u0026ldquo;对于 nums 中的每一个 num\u0026hellip;\u0026rdquo; 二、 精准控制：auto, \u0026amp;, const 的威力 for 循环声明部分的写法，直接决定了循环的效率和安全性。auto 关键字和引用修饰符是这里的关键。\n声明 行为 解释与最佳用途 for (auto item : ...) 拷贝 (Copy) 每次循环都会创建一个元素的副本。仅适用于 int 等基本类型，或你需要在循环内修改副本而不影响原容器时。大多数情况应避免。 for (auto\u0026amp; item : ...) 引用 (Reference) item 成为容器中原始元素的别名，无拷贝开销。用于需要修改原始容器元素的情况。 for (const auto\u0026amp; item : ...) 常量引用 item 成为原始元素的只读别名，无拷贝开销。这是最常用、最推荐的只读遍历方式，兼具高效与安全。 for (auto\u0026amp;\u0026amp; item : ...) 转发/通用引用 (高级) 能完美处理各种情况，是泛型编程中的最稳妥选择。日常使用中，const auto\u0026amp; 已足够好。 记忆法则:\n要修改？用 auto\u0026amp;。 只读取？用 const auto\u0026amp;。 不确定/写模板？用 auto\u0026amp;\u0026amp;。 元素是 int 这种小东西且不修改？直接 auto 也无妨。 三、 结构化绑定 (C++17)：优雅地解包 当你的容器元素是 std::pair, std::tuple 或 struct 时，结构化绑定可以让你的范围 for 循环瞬间变得优雅。\n示例：遍历 std::map\n1 2 3 4 5 6 7 8 9 10 11 std::map\u0026lt;std::string, int\u0026gt; scores = {{\u0026#34;Alice\u0026#34;, 95}, {\u0026#34;Bob\u0026#34;, 88}}; // C++17 之前 for (const auto\u0026amp; pair : scores) { std::cout \u0026lt;\u0026lt; pair.first \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; pair.second \u0026lt;\u0026lt; std::endl; } // C++17 及之后：一步解包！ for (const auto\u0026amp; [name, score] : scores) { std::cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; score \u0026lt;\u0026lt; std::endl; } 优势: 直接在循环变量声明中为元素的各个成员命名，代码更扁平、更具可读性。\n四、 std::ranges (C++20/23)：让范围 for 成为\u0026quot;完全体\u0026quot; std::ranges 库通过视图 (Views) 和管道操作符 |，彻底释放了范围 for 循环的潜力，补全了它所有的功能短板。\n4.1 iota：你的数字生成器 iota 是一个数字序列生成器，是 C++ 版本的 range()。\n(py是最好的语言.cpp)\n1 2 3 4 5 6 #include \u0026lt;ranges\u0026gt; // 模拟 for (int i = 0; i \u0026lt; 10; i++) for (int i : std::views::iota(0, 10)) { // ... } 4.2 视图：懒惰的数据处理流水线 视图是\u0026quot;懒惰\u0026quot;的、不存储数据的\u0026quot;操作指令\u0026quot;。你可以用 | 把它们串联起来，形成一条数据处理流水线。\n视图 功能 views::reverse 反转序列 views::filter 按条件筛选元素 views::transform 对每个元素进行转换 views::take(n) 只取前 n 个元素 views::drop(n) 跳过前 n 个元素 示例：组合的力量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;vector\u0026gt; #include \u0026lt;ranges\u0026gt; #include \u0026lt;iostream\u0026gt; std::vector\u0026lt;int\u0026gt; data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; // 需求：打印 data 中所有偶数的平方，并按倒序输出 auto pipeline = data | std::views::filter([](int n){ return n % 2 == 0; }) // 筛选偶数 | std::views::transform([](int n){ return n * n; }) // 计算平方 | std::views::reverse; // 反转结果 // 此时，pipeline 只是一个\u0026#34;配方\u0026#34;，没有任何计算发生 for (int result : pipeline) { // 遍历时，流水线才启动 std::cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 输出: 100 64 36 16 4 } 4.3 enumerate：最优雅的索引循环 这是范围 for 循环的终极梦想，完美解决了\u0026quot;无法直接获取索引\u0026quot;的痛点。\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;ranges\u0026gt; #include \u0026lt;iostream\u0026gt; std::vector\u0026lt;std::string\u0026gt; names = {\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charlie\u0026#34;}; // 结合结构化绑定，同时获取索引和值 for (const auto\u0026amp; [index, name] : std::views::enumerate(names)) { std::cout \u0026lt;\u0026lt; \u0026#34;Index \u0026#34; \u0026lt;\u0026lt; index \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; std::endl; } 最终总结 C++ 版本 for 循环的演进 核心能力 C++11 for (auto\u0026amp; item : container) 基础遍历：告别手动索引，更安全、简洁。 C++17 for (const auto\u0026amp; [k, v] : map) 结构化绑定：优雅地处理 pair, tuple 等复合类型。 C++20/23 for (item : container | views::filter(\u0026hellip;)) ranges 视图：实现完全可定制的遍历，如索引循环、筛选、转换、反向、组合等。 现代 C++ 的范围 for 循环，已经从一个简单的语法糖，进化成了一个能够承载复杂、声明式数据处理逻辑的强大框架。掌握它的不同形态，是写出高效、优雅、现代 C++ 代码的关键。\n","permalink":"https://QwQBiG.github.io/posts/fanweiforxunhuan/","summary":"\u003ch1 id=\"c-范围-for-循环从入门到精通的究极无敌炸裂雷霆笔记\"\u003eC++ 范围 for 循环：从入门到精通的究极无敌炸裂雷霆笔记\u003c/h1\u003e\n\u003ch2 id=\"一-核心概念告别索引拥抱元素\"\u003e一、 核心概念：告别索引，拥抱元素\u003c/h2\u003e\n\u003cp\u003e基于范围的 for 循环（C++11 引入）是为了解决一个最常见的编程任务：遍历一个序列（如 vector, string）中的每一个元素。\n它的核心思想是让你直接关注元素本身，而不用手动管理索引 i。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e基础语法:\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e ( declaration : range ) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 循环体\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003erange\u003c/code\u003e\u003c/strong\u003e: 你想要遍历的东西，比如一个 \u003ccode\u003evector\u003c/code\u003e 或 \u003ccode\u003estring\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003edeclaration\u003c/code\u003e\u003c/strong\u003e: 一个变量声明，在每次循环时，\u003ccode\u003erange\u003c/code\u003e 中的一个元素会被赋值（或引用）给这个变量。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e示例：告别传统 \u003ccode\u003efor\u003c/code\u003e 循环\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003estd\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003evector\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e nums \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e {\u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e20\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e30\u003c/span\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 传统写法 (命令式：告诉计算机\u0026#34;如何做\u0026#34;)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (size_t i \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e; i \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e nums.size(); i\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e nums[i] \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 范围 for 写法 (声明式：告诉计算机\u0026#34;想要什么\u0026#34;)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e num : nums) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e num \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e优点:\u003c/strong\u003e\u003c/p\u003e","title":"范围for循环"},{"content":"我要玩臭企鹅（Linux） 咕咕嘎嘎\n紧接着上一篇内容（必须要专业版哦）： Windows家庭版激活成专业版\n高雅人士们虽然有很多虚拟机软件来玩Linux，也比较好使，但是还是想试试win自带的WSL对不对~ 好b（￣▽￣）d~　启动~\n由于网络原因，所以我来分步安装而不去使用直接安装的代码，可以试试（大概没用）：\n1 wsl --install 1.功能启用 在搜索框搜索 “启用或关闭 Windows 功能” 并打开。 勾选以下两项： 适用于 Linux 的 Windows 子系统 虚拟机平台 点击确定，系统会配置组件，完成后 必须重启电脑\n2.手动下载安装 WSL2 内核更新包 以下是网址： 打开GitHub： https://github.com/microsoft/WSL/releases 寻找最新版本（例如 2.3.26 或你看到的最新版）： 在 Assets 栏目下，点击下载：wsl.2.3.26.x64.msi (文件名根据版本号可能略有不同)。 直接下载链接 (如果版本已更新可能失效)： wsl.x64.msi 下载完成后，双击运行该 .msi 文件进行安装。\n3.设置 WSL2 为默认版本 安装完更新包后，右键点击“开始”按钮，选择 终端（管理员），输入并回车：\n1 wsl --set-default-version 2 4.下载Ubuntu镜像 这个是主网址： https://cdimages.ubuntu.com/ubuntu-wsl/ 找到Index of /ubuntu-wsl/noble/daily-live再点击current/ 点击下载noble-wsl-amd64.wsl （不会找可以点这个链接：https://cdimages.ubuntu.com/ubuntu-wsl/noble/daily-live/current/）\n5.使用命令行安装 下载完成后，找到文件夹中。请打开 PowerShell（管理员），先切换到这个文件夹： 例如在D盘：\n1 cd D: 然后运行以下命令：\n1 wsl --install --from-file .\\noble-wsl-amd64.wsl --name Ubuntu-24.04 6.撒花！ 根据提示建一个用户就可以玩啦！ 并且，他会有“欢迎使用WSL”的弹窗，里面会有一些介绍哒~\n","permalink":"https://QwQBiG.github.io/posts/getwsl/","summary":"\u003ch1 id=\"我要玩臭企鹅linux\"\u003e我要玩臭企鹅（Linux）\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e咕咕嘎嘎\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e紧接着上一篇内容（必须要专业版哦）：\n\u003cstrong\u003e\u003ca href=\"../professionaleditionwindows/\"\u003eWindows家庭版激活成专业版\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e高雅人士们虽然有很多虚拟机软件来玩\u003ccode\u003eLinux\u003c/code\u003e，也比较好使，但是还是想试试\u003ccode\u003ewin\u003c/code\u003e自带的\u003ccode\u003eWSL\u003c/code\u003e对不对~\n好b（￣▽￣）d~　启动~\u003c/p\u003e\n\u003cp\u003e由于\u003cstrong\u003e网络原因\u003c/strong\u003e，所以我来分步安装而不去使用直接安装的代码，可以试试（大概没用）：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewsl --install\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"1功能启用\"\u003e1.功能启用\u003c/h2\u003e\n\u003cp\u003e在搜索框搜索 “启用或关闭 Windows 功能” 并打开。\n勾选以下\u003cstrong\u003e两\u003c/strong\u003e项：\n适用于 Linux 的 Windows 子系统\n虚拟机平台\n点击确定，系统会配置组件，完成后 必须\u003cstrong\u003e重启\u003c/strong\u003e电脑\u003c/p\u003e\n\u003ch2 id=\"2手动下载安装-wsl2-内核更新包\"\u003e2.手动下载安装 WSL2 内核更新包\u003c/h2\u003e\n\u003cp\u003e以下是网址：\n打开\u003ccode\u003eGitHub\u003c/code\u003e：\n\u003ccode\u003ehttps://github.com/microsoft/WSL/releases\u003c/code\u003e\n寻找最新版本（例如 2.3.26 或你看到的最新版）：\n在 Assets 栏目下，点击下载：wsl.2.3.26.x64.msi (文件名根据版本号可能略有不同)。\n直接下载链接 (如果版本已更新可能失效)： wsl.x64.msi\n下载完成后，双击运行该 .msi 文件进行安装。\u003c/p\u003e\n\u003ch2 id=\"3设置-wsl2-为默认版本\"\u003e3.设置 WSL2 为默认版本\u003c/h2\u003e\n\u003cp\u003e安装完更新包后，右键点击“开始”按钮，选择 终端（\u003cstrong\u003e管理员\u003c/strong\u003e），输入并回车：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-Powershell\" data-lang=\"Powershell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewsl --set-default-version \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"4下载ubuntu镜像\"\u003e4.下载Ubuntu镜像\u003c/h2\u003e\n\u003cp\u003e这个是主网址：\n\u003ccode\u003ehttps://cdimages.ubuntu.com/ubuntu-wsl/\u003c/code\u003e\n找到\u003ccode\u003eIndex of /ubuntu-wsl/noble/daily-live\u003c/code\u003e再点击\u003ccode\u003ecurrent/\u003c/code\u003e\n点击下载\u003ccode\u003enoble-wsl-amd64.wsl\u003c/code\u003e\n（不会找可以点这个链接：\u003ccode\u003ehttps://cdimages.ubuntu.com/ubuntu-wsl/noble/daily-live/current/\u003c/code\u003e）\u003c/p\u003e\n\u003ch2 id=\"5使用命令行安装\"\u003e5.使用命令行安装\u003c/h2\u003e\n\u003cp\u003e下载完成后，找到文件夹中。请打开 PowerShell（\u003cstrong\u003e管理员\u003c/strong\u003e），先切换到这个文件夹：\n例如在D盘：\u003c/p\u003e","title":"搞搞WSL"},{"content":"Windows 激活成专业版 1. 断开网络（拔网线或关 WiFi）。\n原因：联网状态下验证密钥会失败，断网可以让它先通过验证并执行升级文件。\n2. 点击 开始 -\u0026gt; 设置 搜索并点开 “更改产品密钥” 输入这个通用的转换密钥（这是微软官方给出的 RTM 安装密钥，非破解）：\n1 VK7JG-NPHTM-C97JM-9MPGT-3V66T 3. 点击“下一步”或“开始”。 系统会提示“无法验证密钥”或者直接提示“准备升级”。 让它跑完进度条，电脑会自动重启。\n4. 重启之后连上网，右键开始菜单，以管理员身份运行 Windows PowerShell (管理员！) 复制并粘贴下面这行新命令，然后回车：\n1 irm https://get.activated.win | iex 5. 等待几秒钟，会出现一个彩色的菜单窗口。 按键盘上的数字键 1 (选择 HWID 激活)。 HWID 是永久数字权利激活，最稳的一种。 脚本跑完后提示绿色文字（Successfully activated）即可关闭。\n然后就是可以搞 WSL 玩玩 Linux 啦! 还有沙箱可以搞病毒乱斗\u0026hellip;\n接着玩哈： 搞搞WSL\n","permalink":"https://QwQBiG.github.io/posts/professionaleditionwindows/","summary":"\u003ch1 id=\"windows-激活成专业版\"\u003eWindows 激活成专业版\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e1.\u003c/strong\u003e 断开网络（拔网线或关 \u003ccode\u003eWiFi\u003c/code\u003e）。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e原因：联网状态下验证密钥会失败，断网可以让它先通过验证并执行升级文件。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003e2.\u003c/strong\u003e 点击 开始 -\u0026gt; 设置 搜索并点开 “更改产品密钥”\n输入这个通用的转换密钥（这是微软官方给出的 \u003ccode\u003eRTM\u003c/code\u003e 安装密钥，非破解）：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eVK7JG-NPHTM-C97JM-9MPGT-3V66T\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e3.\u003c/strong\u003e 点击“下一步”或“开始”。\n系统会提示“无法验证密钥”或者直接提示“准备升级”。\n让它跑完进度条，电脑会自动重启。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e4.\u003c/strong\u003e 重启之后连上网，右键开始菜单，以管理员身份运行 \u003ccode\u003eWindows PowerShell\u003c/code\u003e (管理员！)\n复制并粘贴下面这行新命令，然后回车：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eirm https://get.activated.win | iex\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e5.\u003c/strong\u003e 等待几秒钟，会出现一个彩色的菜单窗口。\n按键盘上的数字键 1 (选择 HWID 激活)。\nHWID 是永久数字权利激活，最稳的一种。\n脚本跑完后提示绿色文字（Successfully activated）即可关闭。\u003c/p\u003e\n\u003cp\u003e然后就是可以搞 \u003ccode\u003eWSL\u003c/code\u003e 玩玩 \u003ccode\u003eLinux\u003c/code\u003e 啦!\n还有沙箱可以搞病毒乱斗\u0026hellip;\u003c/p\u003e\n\u003cp\u003e接着玩哈：\n\u003cstrong\u003e\u003ca href=\"../getwsl/\"\u003e搞搞WSL\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e","title":"Windows家庭版激活成专业版 "},{"content":"Docker 部署 FRP 客户端避坑指南 适用于： Linux (Ubuntu/CentOS) + Docker 环境，目标是穿透本地 SSH 或其他服务。\n核心结论 不要使用 Docker 默认的网络模式，直接使用 Host 模式 + 强制指定 DNS。\n这将解决：容器内网不通、DNS 解析失败、路由器重启导致 IP 变动失效等所有常见问题。\n1. 部署命令 (模版) 直接复制替换参数，一步到位：\n1 2 3 4 5 6 7 8 9 10 11 sudo docker run -d \\ --name frp-client \\ --restart=always \\ --network host \\ --dns 223.5.5.5 \\ --dns 8.8.8.8 \\ vaalacat/frp-panel \\ client -s \u0026lt;你的服务端Key\u0026gt; \\ -i \u0026lt;你的客户端ID\u0026gt; \\ --api-url \u0026lt;面板API地址\u0026gt; \\ --rpc-url \u0026lt;面板RPC地址\u0026gt; 本地地址 (Local IP): 填 127.0.0.1\n原因： 配合 Host 模式，127.0.0.1 永远指向本机。即使路由器分配的局域网 IP 变了（如 .12 变 .13），配置依然有效。\n本地端口 (Local Port): 填 22 (SSH) 或其他真实端口\n远程端口 (Remote Port): 填公网服务器已放行的端口 (如 8080, 2222 等)\n3. 故障排查速查表 如果状态不是 Online，按以下顺序检查：\n看日志 (唯一真理):\n1 sudo docker logs --tail 20 frp-client 常见报错及对策：\ndns lookup error / i/o timeout: 没加 --dns 参数，容器断网了。 connect to server failed: 公网服务器挂了，或参数填错。 connect to 127.0.0.1:22 connection refused: 没加 --network host 参数，容器里找不到 SSH 服务。 remote port is already in use: 公网端口被占，去网页换个远程端口。 一句话总结： Docker 跑 FRP，认准 --network host 和 --dns，内网 IP 填 127.0.0.1，永远不掉线。\n","permalink":"https://QwQBiG.github.io/posts/yuancheng/","summary":"\u003ch1 id=\"docker-部署-frp-客户端避坑指南\"\u003eDocker 部署 FRP 客户端避坑指南\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e适用于：\u003c/strong\u003e Linux (Ubuntu/CentOS) + Docker 环境，目标是穿透本地 SSH 或其他服务。\u003c/p\u003e\n\u003ch2 id=\"核心结论\"\u003e核心结论\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e不要使用 Docker 默认的网络模式，直接使用 Host 模式 + 强制指定 DNS。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e这将解决：容器内网不通、DNS 解析失败、路由器重启导致 IP 变动失效等所有常见问题。\u003c/p\u003e\n\u003ch2 id=\"1-部署命令-模版\"\u003e1. 部署命令 (模版)\u003c/h2\u003e\n\u003cp\u003e直接复制替换参数，一步到位：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e11\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo docker run -d \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e  --name frp-client \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e  --restart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003ealways \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e  --network host \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e  --dns 223.5.5.5 \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e  --dns 8.8.8.8 \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e  vaalacat/frp-panel \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e  client -s \u0026lt;你的服务端Key\u0026gt; \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e  -i \u0026lt;你的客户端ID\u0026gt; \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e  --api-url \u0026lt;面板API地址\u0026gt; \u003cspan style=\"color:#ae81ff\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e\u003c/span\u003e  --rpc-url \u0026lt;面板RPC地址\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e本地地址 (Local IP):\u003c/strong\u003e 填 \u003ccode\u003e127.0.0.1\u003c/code\u003e\u003c/p\u003e","title":"远程失灵了"},{"content":"文章列表 第一篇：K8s学习笔记\n简介：就是K8s\n第二篇：我の组会\n简介：每周二下午三点三楼组会（简称233）\n第三篇：远程失灵了\n简介：突发情况\n","permalink":"https://QwQBiG.github.io/series/yunwei/","summary":"\u003ch2 id=\"文章列表\"\u003e文章列表\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e第一篇：\u003ca href=\"../../posts/yunweistudy/\"\u003eK8s学习笔记\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e简介：就是K8s\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e第二篇：\u003ca href=\"../../posts/zuhui/\"\u003e我の组会\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e简介：每周二下午三点三楼组会（简称233）\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e第三篇：\u003ca href=\"../../posts/yuancheng/\"\u003e远程失灵了\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e简介：突发情况\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"运维"},{"content":"以下是2025.11.20第一次搞得周报 C已完。C++已学完STL容器和算法（和一些好玩的特性）。 数据结构在学STL都涉及了，纯学数据结构的话停留在串。 运维相关内容多且杂，具体内容见组会报告。\n之后有点东西都可以从这写着，刚做草稿： 比如今天，2025.11.23开始使用CLion来做Qt的程序。 而且，给网站上搞了一个昼夜切换的无敌按键（hhhh）。 还有猫猫砸钢琴音乐播放器！！！ 和闪光miku！\n12.23 图灵完备里面目前是在学逻辑电路和数字电路 -\u0026gt; 底层、嵌入式； openCV -\u0026gt; 机器视觉； 自己配MinGW和Cmake来配置openCV和yolov8，然后把MinGW换掉， 换成MSVC，来使用显卡（不然就只有5帧左右）； 要学ROS 2\n我现在不是在“配置”，而是在当 NVIDIA 和 OpenCV 的测试工程师，请问了：适配呢？ （20 多分钟编译 + 一堆 C1012 + LNK1181）\n最终环境：CLion + VS2026的MSVC + TensorRT 10 + CUDA 13.1 + OpenCV 4.12 + Yolov8\n12.26 教员生日快乐！！！\n12.27 刷LeetCode\u0026hellip;\n","permalink":"https://QwQBiG.github.io/posts/zhouji/","summary":"\u003ch2 id=\"以下是20251120第一次搞得周报\"\u003e以下是2025.11.20第一次搞得周报\u003c/h2\u003e\n\u003cp\u003eC已完。C++已学完STL容器和算法（和一些好玩的特性）。\n数据结构在学STL都涉及了，纯学数据结构的话停留在串。\n运维相关内容多且杂，具体内容见组会报告。\u003c/p\u003e\n\u003ch3 id=\"之后有点东西都可以从这写着刚做草稿\"\u003e之后有点东西都可以从这写着，刚做草稿：\u003c/h3\u003e\n\u003cp\u003e比如今天，2025.11.23开始使用CLion来做Qt的程序。\n而且，给网站上搞了一个昼夜切换的无敌按键（hhhh）。\n还有猫猫砸钢琴音乐播放器！！！\n和闪光miku！\u003c/p\u003e\n\u003ch3 id=\"1223\"\u003e12.23\u003c/h3\u003e\n\u003cp\u003e图灵完备里面目前是在学逻辑电路和数字电路 -\u0026gt; 底层、嵌入式；\nopenCV -\u0026gt; 机器视觉；\n自己配MinGW和Cmake来配置openCV和yolov8，然后把MinGW换掉，\n换成MSVC，来使用显卡（不然就只有5帧左右）；\n要学ROS 2\u003c/p\u003e\n\u003cp\u003e我现在不是在“配置”，而是在当 NVIDIA 和 OpenCV 的测试工程师，请问了：适配呢？\n（20 多分钟编译 + 一堆 C1012 + LNK1181）\u003c/p\u003e\n\u003cp\u003e最终环境：CLion + VS2026的MSVC + TensorRT 10 + CUDA 13.1 + OpenCV 4.12 + Yolov8\u003c/p\u003e\n\u003ch3 id=\"1226\"\u003e12.26\u003c/h3\u003e\n\u003cp\u003e教员生日快乐！！！\u003c/p\u003e\n\u003ch3 id=\"1227\"\u003e12.27\u003c/h3\u003e\n\u003cp\u003e刷LeetCode\u0026hellip;\u003c/p\u003e","title":"我の周报"},{"content":"容器就是数据结构啦~\n","permalink":"https://QwQBiG.github.io/posts/stlcontainer/","summary":"\u003cp\u003e容器就是数据结构啦~\u003c/p\u003e","title":"STL 容器"},{"content":"算法最爽了~\n","permalink":"https://QwQBiG.github.io/posts/stlalgorithm/","summary":"\u003cp\u003e算法最爽了~\u003c/p\u003e","title":"STL 算法"},{"content":"Kubernetes 学习笔记 1 核心思想篇：两大基石 1. 为何选择 Kubernetes？ 单个 Docker 容器是孤立的。当容器数量增多，我们会面临一系列棘手的问题：\n故障恢复：一个容器挂了怎么办？ 服务发现：容器 B 如何找到容器 A 的 IP 地址？ 负载均衡：如何将流量平均分配给多个相同的容器？ 扩缩容：如何根据负载自动增加或减少容器数量？ Kubernetes (K8s) 就是一个容器编排平台，它以标准化的方式完美地解决了以上所有问题。\n2. 命令式 vs. 声明式 (转变) 命令式 (Imperative)：你一步步告诉 K8s “做什么” (kubectl create, kubectl scale)。这就像手动驾驶，直观但难以追踪和重复。 声明式 (Declarative)：你向 K8s 提交一个 YAML 文件，告诉它你**“想要什么状态”**。这就像设定导航目的地，K8s 会自己想办法开车到达，并且如果偏离了航线（比如有 Pod 挂了），它会自动修正。这是 K8s 的精髓，也是现代化的管理方式。 环境搭建篇：Kind (Kubernetes in Docker) 在复杂的网络环境下，使用 Kind 搭建本地集群是最可靠、轻量且快速的方式。\n1. 安装核心工具 安装 kubectl (K8s 命令行客户端)\n1 2 # (根据官方文档，使用 apt 或其他包管理器安装) sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install -y kubectl 安装 Go 语言环境 (用于安装 Kind)\n1 sudo apt-get install golang-go -y 设置 Go 国内代理并安装 kind\n这是解决网络问题的关键，goproxy.cn 会加速模块下载。\n1 2 3 export GOPROXY=https://goproxy.cn,direct go install sigs.k8s.io/kind@v0.22.0 sudo mv ~/go/bin/kind /usr/local/bin/ 验证安装\n1 2 kubectl version --client kind version 2. 编写 Kind 集群配置文件 这份文件解决了两个关键问题：① K8s 核心组件镜像的拉取问题；② 虚拟机端口冲突问题。\n创建 kind-config.yaml 文件： 1 nano kind-config.yaml 粘贴以下内容： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 kind: Cluster apiVersion: kind.x-k8s.io/v1alpha4 # 解决 K8s 核心组件镜像拉取问题 kubeadmConfigPatches: - | apiVersion: kubeadm.k8s.io/v1beta3 kind: ClusterConfiguration imageRepository: registry.aliyuncs.com/google_containers nodes: - role: control-plane kubeadmConfigPatches: - | kind: InitConfiguration nodeRegistration: kubeletExtraArgs: node-labels: \u0026#34;ingress-ready=true\u0026#34; # 解决宿主机端口占用问题，将 80/443 映射到高位端口 extraPortMappings: - containerPort: 80 hostPort: 52014 protocol: TCP - containerPort: 443 hostPort: 52015 protocol: TCP 3. 启动与销毁集群 启动集群 1 kind create cluster --config=kind-config.yaml 验证集群就绪 1 2 kubectl get nodes # 预期输出一个名为 kind-control-plane 的节点，状态为 Ready 销毁集群 (学习结束时) 1 kind delete cluster YAML 核心篇：Pod 的“蓝图” 1. YAML 四段式结构 apiVersion: API 版本，如 v1 kind: 资源类型，如 Pod metadata: 元数据，包括 name, namespace, labels spec: 期望状态，定义了资源的核心属性 2. 单容器 Pod 示例 1 2 3 4 5 6 7 8 9 10 apiVersion: v1 kind: Pod metadata: name: my-nginx-pod spec: containers: - name: nginx-container image: nginx:1.22 ports: - containerPort: 80 3. 多容器 Pod (Sidecar 模式) 与数据共享 通过 volumes 和 volumeMounts 实现一个 Pod 内多个容器间的文件共享。\nspec.volumes: 在 Pod 层面定义一个共享存储卷（“储藏室”）。 spec.containers[].volumeMounts: 在容器层面将共享卷挂载到容器内的特定路径（“开一扇门到储藏室”）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 apiVersion: v1 kind: Pod metadata: name: multi-container-demo spec: # 1. 定义一个名为 \u0026#34;shared-html\u0026#34; 的共享卷 volumes: - name: shared-html emptyDir: {} containers: # 容器一：Nginx - name: nginx-container image: nginx:1.22 # 2. 将共享卷挂载到 Nginx 的网站根目录 volumeMounts: - name: shared-html mountPath: /usr/share/nginx/html # 容器二：Busybox (Sidecar) - name: sidecar-container image: busybox:1.35 command: [\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;while true; do date \u0026gt;\u0026gt; /var/log/index.html; sleep 5; done\u0026#34;] # 3. 将同一个共享卷挂载到 Busybox 的日志目录 volumeMounts: - name: shared-html mountPath: /var/log 日常操作与调试篇 (kubectl) 1. 核心管理命令 应用配置: kubectl apply -f [文件名.yaml] 删除资源: kubectl delete -f [文件名.yaml] 或 kubectl delete pod [pod名] 2. 状态检查“三板斧” kubectl get : 快速查看资源列表和状态。 kubectl get pods: 查看当前命名空间的 Pod。 kubectl get pods -n \u0026lt;命名空间\u0026gt;: 查看指定命名空间的 Pod。 kubectl get pods -A: 查看所有命名空间的 Pod。 kubectl get pods -o wide: 查看更多信息（IP, 所在节点）。 kubectl describe : 查看资源的详细信息和事件日志。 kubectl describe pod \u0026lt;pod名\u0026gt; 排错关键：永远第一时间查看最下方的 Events 部分，它记录了 Pod 创建过程中的所有成功和失败信息。\nkubectl logs : 查看容器内部的标准输出日志。 kubectl logs \u0026lt;pod名\u0026gt; kubectl logs \u0026lt;pod名\u0026gt; -c \u0026lt;容器名\u0026gt;: 查看多容器 Pod 中特定容器的日志。 kubectl logs \u0026lt;pod名\u0026gt; --previous: 查看上一次崩溃退出的容器的日志。 3. 交互命令 kubectl exec : 进入一个正在运行的容器内部。 1 kubectl exec -it \u0026lt;pod名\u0026gt; -c \u0026lt;容器名\u0026gt; -- /bin/bash 4. 资源组织 Namespace (文件夹): 用于逻辑隔离。\n创建: kubectl create namespace \u0026lt;命名空间名\u0026gt; 删除: kubectl delete namespace \u0026lt;命名空间名\u0026gt; (会删除其内部所有资源) Labels \u0026amp; Selectors (标签与筛选器): 用于对资源进行分组和筛选。\n在 metadata.labels 中定义键值对。 使用 -l 参数进行筛选: kubectl get pods -l app=my-app,env=prod 实战排错篇：网络问题终极方案 问题现象: ImagePullBackOff / ErrImagePull Pod 状态显示拉取镜像失败，describe 事件中提示 i/o timeout 或 not found。\n方案一：(推荐) 修改 YAML，使用国内镜像源 直接在 YAML 的 image 字段中使用国内的、可访问的镜像地址。\n1 2 3 4 5 6 spec: containers: - name: redis-container # 原镜像: image: redis:7.0 # 修改后: image: m.daocloud.io/docker.io/library/redis:7.0 方案二：(极端网络环境) 本地加载 当所有镜像源都无法从 Kind 节点内部访问时，采用“主机下载，加载进集群”的策略。\n在主机 (Ubuntu VM) 上拉取镜像\n1 docker pull m.daocloud.io/docker.io/library/redis:7.0 为镜像打上官方标签 (关键)\nK8s Pod 的 YAML 里使用的是官方短名称，所以必须打这个标签。\n1 docker tag m.daocloud.io/docker.io/library/redis:7.0 redis:7.0 将打好标签的镜像加载进 Kind 集群\n1 kind load docker-image redis:7.0 最后，使用包含官方短名称 (image: redis:7.0) 的 YAML 文件进行部署。 K8s 会直接使用节点上的本地镜像，不再进行网络拉取。\nKubernetes 学习周报 2 核心主题：从\u0026quot;裸砖\u0026quot;到\u0026quot;自动化建筑\u0026quot; - Pod 的高级管理 从管理单个、脆弱的 Pod，过渡到使用 Deployment 和 Service 来部署、管理和暴露真正健壮、高可用的应用。\n第一部分：环境搭建与镜像管理（基础） 1. 搭建本地 Kubernetes (Kind) 环境 目标： 在本地快速搭建一个功能完整的 K8s 集群用于学习和实验。\n工具： Kind (Kubernetes in Docker)，它将 K8s 节点作为 Docker 容器运行，启动快，资源占用少。\n关键步骤：\n安装 kind CLI：\n1 2 3 4 # 推荐：为 Go 语言设置国内代理，然后通过 go install 安装 export GOPROXY=https://goproxy.cn,direct go install sigs.k8s.io/kind@v0.22.0 sudo mv ~/go/bin/kind /usr/local/bin/ 备注： 这是解决国内网络环境下 kind 程序下载困难的最佳实践。GOPROXY 环境变量是关键。\n编写 kind-config.yaml 配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 kind: Cluster apiVersion: kind.x-k8s.io/v1alpha4 nodes: - role: control-plane # 关键配置1: 端口映射，用于后续从主机访问 NodePort 服务 extraPortMappings: - containerPort: 30007 # Kind 节点(容器)内部的端口 hostPort: 8080 # 映射到宿主机(VM或物理机)的端口 protocol: TCP # 关键配置2: 指定 K8s 核心组件的镜像仓库 kubeadmConfigPatches: - | apiVersion: kubeadm.k8s.io/v1beta3 kind: ClusterConfiguration imageRepository: registry.aliyuncs.com/google_containers 解释：\nextraPortMappings：提前规划端口，解决 NodePort 服务在复杂网络环境下（如VM、远程服务器）难以直接访问的问题。 imageRepository：将 K8s 核心组件的镜像源指向国内的阿里云，从根本上解决了因网络问题导致的集群创建失败。 创建集群：\n1 kind create cluster --config=kind-config.yaml 2. 镜像管理：一劳永逸的\u0026quot;镜像预加载\u0026quot;SOP 问题背景： 在受限的网络环境中，K8s 节点（Kubelet）无法直接从 Docker Hub 等官方源拉取应用镜像，导致 Pod 状态卡在 ImagePullBackOff 或 ErrImagePull。\n核心思想： 既然 K8s 节点自己\u0026quot;出不去\u0026quot;，我们就在网络通畅的主机上把镜像准备好，然后强行\u0026quot;塞\u0026quot;给它。\n标准操作流程 (SOP)：\n【拉取】 在主机终端，从可靠的国内镜像源（如 m.daocloud.io）拉取镜像。\n1 docker pull m.daocloud.io/docker.io/library/nginx:1.22 【标记】 为拉取下来的镜像打上官方的\u0026quot;短名称\u0026quot;标签。这是为了让镜像名与 YAML 文件中的 image 字段完全匹配。\n1 docker tag m.daocloud.io/docker.io/library/nginx:1.22 nginx:1.22 【加载】 使用 kind load 命令，将主机上的镜像复制到 Kind 集群的内部镜像仓库中。\n1 kind load docker-image nginx:1.22 备注： 养成习惯，在部署任何包含新镜像的应用前，都先执行此\u0026quot;三部曲\u0026quot;。这能 100% 避免因镜像拉取失败导致的部署问题，极大提高学习和实验效率。\n第二部分：核心控制器 - Deployment 1. 为何需要 Deployment：告别\u0026quot;裸Pod\u0026quot; \u0026ldquo;裸Pod\u0026quot;的脆弱性： 直接创建的 Pod，在被删除、所在节点宕机或自身进程崩溃后，会永久消失，导致服务中断。\nDeployment 的价值：\n高可用性 (自愈能力): Deployment 通过管理 ReplicaSet，确保始终有预定数量的 Pod 副本在运行。当有 Pod 意外消失时，它会自动创建一个新的来替代。 可伸缩性: 可以轻松地增加或减少 Pod 的副本数量，以应对流量变化。 声明式更新: 提供强大的滚动更新和回滚机制，实现应用的平滑发布和快速修复。 2. 编写 Deployment YAML 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 apiVersion: apps/v1 # Deployment 属于 apps API 组 kind: Deployment metadata: name: my-app # Deployment 的名字 spec: replicas: 3 # 期望状态：需要 3 个 Pod 副本 # selector: 定义了 Deployment 如何\u0026#34;识别\u0026#34;它应该管理的孩子(Pod) selector: matchLabels: app: my-app # 匹配所有带有 \u0026#34;app: my-app\u0026#34; 标签的 Pod # template: Pod 的\u0026#34;出生模板\u0026#34; template: metadata: # 关键：模板中的 Pod 必须带有能与 selector 匹配的标签 labels: app: my-app spec: # 这里是标准的 Pod.spec 定义 containers: - name: nginx image: nginx:1.22 ports: - containerPort: 80 核心关系解释： Deployment 通过 spec.selector 来找到并管理 Pods。ReplicaSet (由 Deployment 自动创建) 则根据 spec.template 来创建新的 Pod。template.metadata.labels 和 selector.matchLabels 之间的匹配是它们能协同工作的关键。\n3. 核心运维操作 部署与查看：\n1 2 3 4 kubectl apply -f \u0026lt;deployment.yaml\u0026gt; kubectl get deployment kubectl get replicaset # 查看 Deployment 创建的 rs kubectl get pods # 查看 rs 创建的 pods 伸缩 (Scaling)：\n命令式 (快速): kubectl scale deployment my-app --replicas=5 声明式 (推荐): 修改 YAML 文件中的 replicas 字段，然后重新 kubectl apply 滚动更新 (Rolling Update)：\n修改 YAML 文件中的 template.spec.containers[0].image 字段为新版本 执行 kubectl apply -f \u0026lt;deployment.yaml\u0026gt; 监控更新过程： 1 2 3 4 # 实时观察 Pod 的增删交替过程 kubectl get pods -w # 查看官方的滚动更新状态报告 kubectl rollout status deployment/my-app 回滚 (Rollback)：\n查看历史版本：kubectl rollout history deployment/my-app 一键回滚到上一个版本：kubectl rollout undo deployment/my-app 回滚到指定版本：kubectl rollout undo deployment/my-app --to-revision=\u0026lt;NUMBER\u0026gt; 第三部分：服务发现 - Service 1. 为何需要 Service：解决 Pod 的\u0026quot;动态\u0026quot;问题 问题背景： Deployment 管理的 Pod IP 地址是动态的、不固定的，且 Pod 会随时被销毁和重建。应用之间无法直接通过 Pod IP 进行可靠通信。\nService 的价值： 为一组功能相同的 Pod 提供一个稳定、统一的访问入口。它有固定的虚拟 IP (ClusterIP) 和 DNS 名称，并能自动对后端的健康 Pod 进行负载均衡。\n2. Service 类型与实践 ClusterIP (默认类型 - 对内交通) 用途： 用于集群内部服务之间的通信，是构建微服务架构的基础。\nYAML 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 apiVersion: v1 kind: Service metadata: name: my-app-svc # Service 的名字，也是内部的 DNS 名 spec: type: ClusterIP # 可省略 # selector: Service 如何找到它要代理的 Pod selector: app: my-app # 匹配所有带 \u0026#34;app: my-app\u0026#34; 标签的 Pod ports: - port: 80 # Service 自身监听的端口 targetPort: 80 # 转发到后端 Pod 容器的目标端口 测试方法： 启动一个临时的调试 Pod，通过 Service 的 DNS 名称访问。\n1 2 3 4 # 启动临时 Pod 并进入 shell kubectl run tester --rm -it --image=busybox:1.35 -- /bin/sh # 在临时 Pod 内部访问 / # wget -O- http://my-app-svc NodePort (对外暴露 - 开发/测试用) 用途： 在 ClusterIP 的基础上，在集群的每个节点上都暴露一个相同的静态端口（30000-32767），从而允许从集群外部访问。\nYAML 示例 (在 ClusterIP 基础上修改)：\n1 2 3 4 5 6 7 8 spec: type: NodePort # 明确指定类型 selector: app: my-app ports: - port: 80 targetPort: 80 nodePort: 30007 # 可选，手动指定一个端口方便访问 测试方法：\n获取节点的 IP 地址 (对于 Kind in VM，是 VM 的 IP) 在本地浏览器中访问 http://\u0026lt;Node-IP\u0026gt;:\u0026lt;NodePort\u0026gt; kubectl port-forward (终极调试工具) 用途： 当 NodePort 因复杂的网络环境（防火墙、云安全组）无法访问时，这是最可靠的本地调试方法。\n原理： 在本地机器和指定的 Pod/Service 之间建立一个安全的流量转发隧道。\n使用方法：\n1 2 3 4 # 在一个终端中运行，它会阻塞 kubectl port-forward svc/my-app-svc 8888:80 # 在另一个终端中，访问本地的 8888 端口 curl http://localhost:8888 Kubernetes 学习周报 3 核心思想：十二因子应用 (The Twelve-Factor App) 本周所有学习内容的理论基石，源于云原生开发的最佳实践，特别是第三条：在环境中存储配置。\n目标： 将配置 (Config) 与代码/镜像彻底分离。\n优势：\n高效： 修改配置无需重新构建镜像。 灵活： 同一个镜像可以无缝部署到不同环境（开发、测试、生产）。 安全： 敏感信息（如密码）不会被硬编码到镜像中。 Kubernetes 解决方案：\n非敏感配置：ConfigMap 敏感配置：Secret 运行时数据/文件：Volume 一、ConfigMap：非敏感配置管理 ConfigMap 以键值对（key-value）的形式存储非敏感的配置数据。\n1. 创建 ConfigMap 方式A：从字面值创建 (适用于少量、简单的键值对)\n1 2 # 格式: kubectl create configmap \u0026lt;NAME\u0026gt; --from-literal=\u0026lt;KEY1\u0026gt;=\u0026lt;VALUE1\u0026gt; ... kubectl create configmap my-app-config --from-literal=APP_COLOR=blue --from-literal=APP_GREETING=\u0026#34;Hello World\u0026#34; 方式B：从文件创建 (适用于已有的配置文件)\n1 2 3 4 5 # 1. 先创建本地文件 echo \u0026#34;APP_MODE=production\u0026#34; \u0026gt; app.properties # 2. 从文件创建ConfigMap (文件名将作为key，文件内容作为value) kubectl create configmap my-app-config-from-file --from-file=app.properties 2. 使用 ConfigMap 方式一：作为环境变量注入 Pod 这是最符合\u0026quot;十二因子\u0026quot;理念的方式。Kubelet 在启动容器前，会将指定的 ConfigMap 值设置为容器的环境变量。\npod-with-cm-env.yaml 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 apiVersion: v1 kind: Pod metadata: name: pod-cm-env spec: containers: - name: test-container image: busybox:1.35 # 严谨的 echo 命令，用 \\\u0026#34;...\\\u0026#34; 包围变量以处理空格 command: [ \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;echo The app color is $APP_COLOR and the greeting is \\\u0026#34;$APP_GREETING\\\u0026#34;; sleep 3600\u0026#34; ] env: - name: APP_COLOR # 在容器中定义的环境变量名 valueFrom: configMapKeyRef: # 引用一个ConfigMap的key name: my-app-config # ConfigMap的名字 key: APP_COLOR # ConfigMap中的key - name: APP_GREETING valueFrom: configMapKeyRef: name: my-app-config key: APP_GREETING 部署与验证：\n1 2 3 4 5 6 # 部署前，必须先创建依赖的ConfigMap kubectl create configmap my-app-config --from-literal=APP_COLOR=blue --from-literal=APP_GREETING=\u0026#34;Hello World\u0026#34; # 部署Pod kubectl apply -f pod-with-cm-env.yaml # 查看日志验证 kubectl logs pod-cm-env 方式二：作为文件挂载到 Pod 适用于需要读取传统配置文件的应用。\npod-with-cm-volume.yaml 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 apiVersion: v1 kind: Pod metadata: name: pod-cm-volume spec: containers: - name: test-container image: busybox:1.35 command: [ \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;cat /etc/config/app.properties; sleep 3600\u0026#34; ] # 步骤2: 把下面定义的Volume挂载到容器的指定路径 volumeMounts: - name: config-volume mountPath: /etc/config # 步骤1: 在Pod层面定义一个Volume，数据来源是ConfigMap volumes: - name: config-volume configMap: name: my-app-config-from-file 二、Secret：敏感信息管理 Secret 专用于存储密码、API密钥等敏感数据。其使用方式与 ConfigMap 几乎完全一样，但有关键区别。\n核心区别：\n用途： 专用于敏感数据。 编码： 值默认进行 Base64 编码（注意：不是加密！）。 安全： K8s 会对其提供更强的安全机制（如静态加密、访问控制、内存存储等）。 1. 创建 Secret 1 2 # 格式: kubectl create secret generic \u0026lt;NAME\u0026gt; --from-literal=\u0026lt;KEY1\u0026gt;=\u0026lt;VALUE1\u0026gt; ... kubectl create secret generic db-credentials --from-literal=username=admin --from-literal=password=\u0026#39;S3cr3tP@ssw0rd!\u0026#39; 2. 使用 Secret 与 ConfigMap 类似，仅需将 configMapKeyRef 替换为 secretKeyRef，或将 configMap: 替换为 secret:。\npod-with-secret.yaml (环境变量注入) 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 apiVersion: v1 kind: Pod metadata: name: pod-with-secret spec: containers: - name: test-container image: busybox:1.35 command: [ \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;echo User is $DB_USER and Password is \\\u0026#34;$DB_PASS\\\u0026#34;; sleep 3600\u0026#34; ] env: - name: DB_USER valueFrom: secretKeyRef: # \u0026lt;-- 关键区别 name: db-credentials key: username - name: DB_PASS valueFrom: secretKeyRef: # \u0026lt;-- 关键区别 name: db-credentials key: password 部署与验证：\n1 2 3 4 5 6 # 部署前，必须先创建依赖的Secret kubectl create secret generic db-credentials --from-literal=username=admin --from-literal=password=\u0026#39;S3cr3tP@ssw0rd!\u0026#39; # 部署Pod kubectl apply -f pod-with-secret.yaml # 查看日志验证 (仅用于学习，生产环境严禁打印密码) kubectl logs pod-with-secret 三、Volume：Pod 的存储卷 Volume 是连接外部存储和 Pod 的桥梁，其生命周期与 Pod 绑定（Pod 在，Volume 在）。\n1. emptyDir：Pod 内的临时共享存储 特性：\nPod 创建时，K8s 在节点上为其分配一个空目录。 Pod 删除时，该目录及其内容被永久删除。 容器崩溃重启，数据不丢失。 核心用途： 同一个 Pod 内多个容器之间共享文件（Sidecar 模式）。\nSidecar 示例 pod-with-emptydir.yaml:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 apiVersion: v1 kind: Pod metadata: name: web-server-pod spec: volumes: - name: shared-html emptyDir: {} # 定义一个emptyDir类型的Volume containers: - name: web-server image: nginx volumeMounts: # 挂载Volume - name: shared-html mountPath: /usr/share/nginx/html - name: content-generator image: busybox command: [\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;while true; do echo \\\u0026#34;Generated at $(date)\\\u0026#34; \u0026gt; /html/index.html; sleep 5; done\u0026#34;] volumeMounts: # 挂载同一个Volume - name: shared-html mountPath: /html 验证方法 (端口转发):\n1 2 3 4 # 在一个终端运行 kubectl port-forward pod/web-server-pod 8080:80 # 在另一个终端验证 curl http://localhost:8080 2. hostPath：与节点主机的存储交互 特性：\n将 Node 主机上的文件或目录直接挂载到 Pod 中。 数据不会随 Pod 删除而消失。 重大风险： 破坏 Pod 可移植性，带来严重安全风险。应极力避免在常规应用中使用。 核心用途： 日志收集、监控代理等需要访问节点底层资源的系统级应用。\npod-with-hostpath.yaml 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 apiVersion: v1 kind: Pod metadata: name: pod-hostpath spec: containers: - name: test-container image: busybox:1.35 command: [ \u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;cat /host-data/host-file.txt; sleep 3600\u0026#34; ] volumeMounts: - name: host-storage mountPath: /host-data volumes: - name: host-storage hostPath: path: /mnt/data # 指定要挂载的主机路径 type: Directory 验证方法：\n1 2 3 4 5 6 7 8 9 # 1. 进入Kind节点容器，创建文件 docker exec -it kind-control-plane /bin/bash # root@kind-control-plane:/# mkdir /mnt/data # root@kind-control-plane:/# echo \u0026#34;Hello from Host\u0026#34; \u0026gt; /mnt/data/host-file.txt # root@kind-control-plane:/# exit # 2. 部署Pod kubectl apply -f pod-with-hostpath.yaml # 3. 查看日志 kubectl logs pod-hostpath 突发状况：远程失效了 总结下来就是：Docker 跑 FRP，认准 --network host 和 --dns，内网 IP 填 127.0.0.1，永远不掉线。\n","permalink":"https://QwQBiG.github.io/posts/yunweistudy/","summary":"\u003ch1 id=\"kubernetes-学习笔记-1\"\u003eKubernetes 学习笔记 1\u003c/h1\u003e\n\u003ch2 id=\"核心思想篇两大基石\"\u003e核心思想篇：两大基石\u003c/h2\u003e\n\u003ch3 id=\"1-为何选择-kubernetes\"\u003e1. 为何选择 Kubernetes？\u003c/h3\u003e\n\u003cp\u003e单个 Docker 容器是孤立的。当容器数量增多，我们会面临一系列棘手的问题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e故障恢复\u003c/strong\u003e：一个容器挂了怎么办？\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e服务发现\u003c/strong\u003e：容器 B 如何找到容器 A 的 IP 地址？\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e负载均衡\u003c/strong\u003e：如何将流量平均分配给多个相同的容器？\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e扩缩容\u003c/strong\u003e：如何根据负载自动增加或减少容器数量？\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eKubernetes (K8s) 就是一个\u003cstrong\u003e容器编排平台\u003c/strong\u003e，它以标准化的方式完美地解决了以上所有问题。\u003c/p\u003e\n\u003ch3 id=\"2-命令式-vs-声明式-转变\"\u003e2. 命令式 vs. 声明式 (转变)\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e命令式 (Imperative)\u003c/strong\u003e：你一步步告诉 K8s \u003cstrong\u003e“做什么”\u003c/strong\u003e (\u003ccode\u003ekubectl create\u003c/code\u003e, \u003ccode\u003ekubectl scale\u003c/code\u003e)。这就像手动驾驶，直观但难以追踪和重复。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e声明式 (Declarative)\u003c/strong\u003e：你向 K8s 提交一个 YAML 文件，告诉它你**“想要什么状态”**。这就像设定导航目的地，K8s 会自己想办法开车到达，并且如果偏离了航线（比如有 Pod 挂了），它会自动修正。\u003cstrong\u003e这是 K8s 的精髓，也是现代化的管理方式。\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"环境搭建篇kind-kubernetes-in-docker\"\u003e环境搭建篇：Kind (Kubernetes in Docker)\u003c/h2\u003e\n\u003cp\u003e在复杂的网络环境下，使用 Kind 搭建本地集群是最可靠、轻量且快速的方式。\u003c/p\u003e\n\u003ch3 id=\"1-安装核心工具\"\u003e1. 安装核心工具\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e安装 \u003ccode\u003ekubectl\u003c/code\u003e (K8s 命令行客户端)\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# (根据官方文档，使用 apt 或其他包管理器安装)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt-get update \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e sudo apt-get install -y kubectl\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e安装 Go 语言环境 (用于安装 Kind)\u003c/strong\u003e\u003c/p\u003e","title":"K8s学习笔记"},{"content":"组会报告 1 容我想想上几周我干了什么：\n首先在最开始，我搞了一个VMware开始玩弄Ubuntu，这个时候，我是在有这个项目通知之前，到货了一个鸿蒙系统的平板（书接上回），凭借“来都来了”与“捣鼓捣鼓”的心态，我开始安装搞termux和X11，想着搞个linux终端玩玩，但是因为鸿蒙，所以是无法启动的，但是我都看了好几个视频了，还是想试试linux，所以从电脑装了VMware，我这边是跟着千峰的（BV1VH1aBtEz2 ）视频来的，主要学的是虚拟机相关内容，同时包括一些Ubuntu命令：基础的ls,apt,tree,cd,pwd,cat,管道，重定向等，安装了插件：vmtools,samba,一些命令提示组件啥的（还有TheFuck，白月光），接触了主要是用SSH协议的Xshell远程终端（最后扔了）。算是对linux的Ubuntu发行版有了基础认识哈。（千峰的东西还是太过时了qwq）\n然后就是新机必做的美化，有道是：”用着爽不一定真爽，但看着爽一定是真爽。“终端是块黑黢黢的方块，字体是被压缩成俄式比例的，那确实很可怕了\u0026hellip;那时还没找毛学长，没搞zsh，终端还是bash，此时搞了个kitty图形化终端，以此来搞出来壁纸画面；之后开始使用oh my zsh和字体pl10k，搞出了jb momo（全拼一直忘）和代码高亮，和右键补全，这时的我受到豆沙包和臭鲸鱼的极致恶心，所幸镜像一天10次对话的ChatGPT还像是个人\u0026hellip;但是还是让我感觉出，整这种相对完整的内容，还是博客、论坛、b站（一般）啥的好一些，我的美化，是跟着收藏的一篇CSDN的文章搞得（安装oh-my-zsh，配置命令行高亮，命令提示，打造高效终端_oh my zsh-CSDN博客）。终于，也是有了一个好看些的Ubuntu。\n或许，我们感觉美化有点搞偏了，但是也可以学到pip,git一些下载、拉镜像源的方法，比如说找马云对吧（Gitee）。就像是孔老二说的可以“兴观群怨”的《诗经》，退一步说，这也算是一种识字教育，见识这些奇怪的“鸟兽草木之名”，也有帮助。\n之后，我深刻的了解到、并可以熟练进行Ubuntu的紧急操作界面的恢复\u0026hellip;因为可能是我把第二个开的虚拟机，放到了第一个虚拟机没有清理完全的文件夹，导致lvm卷他找不到，那两天左右，我大概有20次以上的重启到紧急模式到好了到测试的经历，可以说是十分熟练（酸爽）了。\n然后转折点：毛学长给我分了一块实验室服务器的Ubuntu，所以开始搞远程终端的美化：\n最终是扔了Xshell，用了开源的Tabby Terminal，如下图（还没整）哈，这么多好用的远程，难道主要是因为这个有壁纸插件吗？还真是。插件好啊，点下安装就让用。\n然后，在我回宿舍路上，想要点开终端fuck一下，猛然发现连接寄掉了，原因都知道，这是在实验室的内网，问学长让我瞅瞅内网穿透，我听着有点高级哈，”穿透“，像是网安的词。当我下载、点开樱花穿透后：发现，这不是我的世界联机用的吗hh。由此，以及后来用的panel.frplients，以及学长给到的http协议的代理，都是，额，应该是计算机网络都要学的内容，TCP/SSH/HTTP/HTTPS这些协议嗯。以及一点防火墙的设置，都有学到。\n在这些内容的中间，从linux(BV1cq421w72c )到docker（BV14s4y1i7Vf ）（BV1THKyzBER6 ）的基础视频，我是跟着敲了的。当然docker pull 不了镜像，问ai快给我俩问四了，发现是另有缘由是吧（当然有了代理，一路畅通）。\n看的相关的科普视频关于docker,k8s,k3s,docker compose,docker swarm\u0026hellip;比较杂\u0026hellip;\n然后就是调教ai（为了多玩玩docker），想搞个网站，一开始是吧，docker建了个文件夹搞点html,css做了个界面，发现内网\u0026hellip;然后拉了一个wordpress是个动态网站，依旧内网\u0026hellip;再看域名，看累了没搞，之后还想内网穿透，结果https\u0026hellip;相关视频看了大概，网络协议也是大概学到了一些\u0026hellip;\n最终是用的Github Pages静态网站，不用自己搞sql、redis啥的，也不用搞安全，还是很爽的，加上Github Action 发布文章只要win终端git push一下就好了。\n这边，主要是接触了git、前端代码、以及重要的shell内容。\nhttps://qwqbig.github.io/\n网址如上，里面有建站的全流程，想看的话。我应该有两天时间在干这个。\n最后这两天就感到有点子无聊了，回到了 STL 和 C++11 以上的好的特性上去玩。\n那我正好鼓捣k8s玩了，还以为要再docker几天的。\n对了，我学过py（第一个学的就是py），脚本方面的接触在网站上建站过程中提及到了也。\n本来我都想开始把原来做的题用cpp重写的，像是把这个世界用Rust重写一遍似的\u0026hellip;(话说蟹教有干翻C++的未来吗，不清楚)。\n写日记挺好玩的，我要同步到https://qwqbig.github.io/上hhh\n欧克，完事了，bye~\n组会报告 2 总结：本周主要搞了 K8s 本地环境的网络与镜像难题，完成了从 kubectl 命令式操作到 YAML 声明式管理的思维转变，掌握了 Pod 高级（应该高级吧）模式（Sidecar）、资源隔离（Namespace/Labels）及标准排错流程。\n主要是 K8s 本地环境搭建与 Pod 编排： 1. 可恶的网：Kind + 国内源\n由于 Minikube 网络受限，转用 Kind (Kubernetes in Docker)。通过配置 GOPROXY 完成源码编译安装，配合 kind-config.yaml 定制国内镜像源及端口映射，解决了环境初始化问题。\n（Kind 把 Docker 容器当成 K8s 的节点（Node）来跑）\n2. 熟悉概念：从命令式到声明式\n基础：熟悉 kubectl 一些基础的动词语法，并且从命令式（CLI）转向声明式（YAML），主要是有版本控制（用 git ）这些好处。\n说是动词语法是因为这些命令的格式差别不大，基本上是动词的变化。\nPod 理解：通过实操 边车（Sidecar） 模式（Nginx + Busybox 共享存储），理解 Pod 作为“最小单元”的共享网络与存储特性。\n存储 是因为同一个卷，网络 是我配置到 YMAL 里面了。\n3. 运维与Debug方法\n镜像策略：对于 ImagePullBackOff，除了替换国内源（好不容易找到个 m.daocloud.io），还掌握了 docker pull + kind load 的离线镜像预加载手段。（就是有点大）\nDebug 流程：建立了标准排错链：若是资源调度问题（如 Crash/PullErr）用 kubectl describe 看 Events，应用内部报错查 kubectl logs。\n4. 搞一搞\n隔离：用 Namespace 进行环境隔离，利用 Labels/Selectors 实现资源的灵活分组与发现。\n实操：在一个全新的 Namespace 中，全流程部署 Redis 7.0（含自定义 Labels），完成从 YAML 编写、镜像加载、服务启动到 exec 验证（进入容器内部，试运行ls, cat 等命令，并 exit 退出。）及最终清理（干净的一）的完整管理周期。\n5.感觉\n为了上面关于运维的内容简洁清晰，我都没有地方说点好玩的废话了，我要先表明我的学习路径，主要一脉相承自我学 STL 的时候，b站上的系统课程 cpp 版本是史前的，内容是繁（烦）多的，一个 sort 用上 lambda 不香嘛、有了范围 for 还用迭代器遍历干啥捏\u0026hellip;\u0026hellip;所以我是去和 ai 搞暧昧玩（？）， ai 回应快，时效性强，可以反复问\u0026hellip;我让她先给出到明年那种学习程度的每个月的学习路径，然后开一个新窗口让她详细来，在一周周的来，发现根本用不了几周几周的，总之就是 快！像催人跑（川音）\u0026hellip;\n但是问题还是有的，这些学习学出来感觉空落落的，像是我这个破网站上搞搞好玩的前端内容，可以直接看到、点击到；我学Qt框架，整出来一个计算器确实简单点的计算可以用到。但是就像学个编程语言光搞算法做题玩了，要想来个工程项目，大抵很难；学运维的这些东西，还是有些难以检验学习成果的\u0026hellip;\u0026hellip;\n就这样。\n组会报告 3 依旧是草稿施工： 好玩的：我在测试自愈时，删除完了立马 kubectl get pods -w 都看不到旧的 Pod 的 Terminating ，只能看见新的 Pod 。\n感受：没有什么问题是加一个中间层解决不了的，如果有，就再来一层。\n因为我们这个网站现在就是 GitHub Actions 搞得，所以我又去深入了解 CI/CD（持续集成/持续部署）了一下，用 docker 搞搞 jenkins 。\n搞了个 qwqOps (AIops)\n","permalink":"https://QwQBiG.github.io/posts/zuhui/","summary":"\u003ch2 id=\"组会报告-1\"\u003e组会报告 1\u003c/h2\u003e\n\u003cp\u003e容我想想上几周我干了什么：\u003c/p\u003e\n\u003cp\u003e首先在最开始，我搞了一个VMware开始玩弄Ubuntu，这个时候，我是在有这个项目通知之前，到货了一个鸿蒙系统的平板（书接上回），凭借“来都来了”与“捣鼓捣鼓”的心态，我开始安装搞termux和X11，想着搞个linux终端玩玩，但是因为鸿蒙，所以是无法启动的，但是我都看了好几个视频了，还是想试试linux，所以从电脑装了VMware，我这边是跟着千峰的（BV1VH1aBtEz2 ）视频来的，主要学的是虚拟机相关内容，同时包括一些Ubuntu命令：基础的ls,apt,tree,cd,pwd,cat,管道，重定向等，安装了插件：vmtools,samba,一些命令提示组件啥的（还有TheFuck，白月光），接触了主要是用SSH协议的Xshell远程终端（最后扔了）。算是对linux的Ubuntu发行版有了基础认识哈。（千峰的东西还是太过时了qwq）\u003c/p\u003e\n\u003cp\u003e然后就是新机必做的美化，有道是：”用着爽不一定真爽，但看着爽一定是真爽。“终端是块黑黢黢的方块，字体是被压缩成俄式比例的，那确实很可怕了\u0026hellip;那时还没找毛学长，没搞zsh，终端还是bash，此时搞了个kitty图形化终端，以此来搞出来壁纸画面；之后开始使用oh my zsh和字体pl10k，搞出了jb momo（全拼一直忘）和代码高亮，和右键补全，这时的我受到豆沙包和臭鲸鱼的极致恶心，所幸镜像一天10次对话的ChatGPT还像是个人\u0026hellip;但是还是让我感觉出，整这种相对完整的内容，还是博客、论坛、b站（一般）啥的好一些，我的美化，是跟着收藏的一篇CSDN的文章搞得（安装oh-my-zsh，配置命令行高亮，命令提示，打造高效终端_oh my zsh-CSDN博客）。终于，也是有了一个好看些的Ubuntu。\u003c/p\u003e\n\u003cp\u003e或许，我们感觉美化有点搞偏了，但是也可以学到pip,git一些下载、拉镜像源的方法，比如说找马云对吧（Gitee）。就像是孔老二说的可以“兴观群怨”的《诗经》，退一步说，这也算是一种识字教育，见识这些奇怪的“鸟兽草木之名”，也有帮助。\u003c/p\u003e\n\u003cp\u003e之后，我深刻的了解到、并可以熟练进行Ubuntu的紧急操作界面的恢复\u0026hellip;因为可能是我把第二个开的虚拟机，放到了第一个虚拟机没有清理完全的文件夹，导致lvm卷他找不到，那两天左右，我大概有20次以上的重启到紧急模式到好了到测试的经历，可以说是十分熟练（酸爽）了。\u003c/p\u003e\n\u003cp\u003e然后转折点：毛学长给我分了一块实验室服务器的Ubuntu，所以开始搞远程终端的美化：\u003c/p\u003e\n\u003cp\u003e最终是扔了Xshell，用了开源的Tabby Terminal，如下图（还没整）哈，这么多好用的远程，难道主要是因为这个有壁纸插件吗？还真是。插件好啊，点下安装就让用。\u003c/p\u003e\n\u003cp\u003e然后，在我回宿舍路上，想要点开终端fuck一下，猛然发现连接寄掉了，原因都知道，这是在实验室的内网，问学长让我瞅瞅内网穿透，我听着有点高级哈，”穿透“，像是网安的词。当我下载、点开樱花穿透后：发现，这不是我的世界联机用的吗hh。由此，以及后来用的panel.frplients，以及学长给到的http协议的代理，都是，额，应该是计算机网络都要学的内容，TCP/SSH/HTTP/HTTPS这些协议嗯。以及一点防火墙的设置，都有学到。\u003c/p\u003e\n\u003cp\u003e在这些内容的中间，从linux(BV1cq421w72c )到docker（BV14s4y1i7Vf ）（BV1THKyzBER6 ）的基础视频，我是跟着敲了的。当然docker pull 不了镜像，问ai快给我俩问四了，发现是另有缘由是吧（当然有了代理，一路畅通）。\u003c/p\u003e\n\u003cp\u003e看的相关的科普视频关于docker,k8s,k3s,docker compose,docker swarm\u0026hellip;比较杂\u0026hellip;\u003c/p\u003e\n\u003cp\u003e然后就是调教ai（为了多玩玩docker），想搞个网站，一开始是吧，docker建了个文件夹搞点html,css做了个界面，发现内网\u0026hellip;然后拉了一个wordpress是个动态网站，依旧内网\u0026hellip;再看域名，看累了没搞，之后还想内网穿透，结果https\u0026hellip;相关视频看了大概，网络协议也是大概学到了一些\u0026hellip;\u003c/p\u003e\n\u003cp\u003e最终是用的Github Pages静态网站，不用自己搞sql、redis啥的，也不用搞安全，还是很爽的，加上Github Action 发布文章只要win终端git push一下就好了。\u003c/p\u003e\n\u003cp\u003e这边，主要是接触了git、前端代码、以及重要的shell内容。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://qwqbig.github.io/\"\u003ehttps://qwqbig.github.io/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e网址如上，里面有建站的全流程，想看的话。我应该有两天时间在干这个。\u003c/p\u003e\n\u003cp\u003e最后这两天就感到有点子无聊了，回到了 STL 和 C++11 以上的好的特性上去玩。\u003c/p\u003e\n\u003cp\u003e那我正好鼓捣k8s玩了，还以为要再docker几天的。\u003c/p\u003e\n\u003cp\u003e对了，我学过py（第一个学的就是py），脚本方面的接触在网站上建站过程中提及到了也。\u003c/p\u003e\n\u003cp\u003e本来我都想开始把原来做的题用cpp重写的，像是把这个世界用Rust重写一遍似的\u0026hellip;(话说蟹教有干翻C++的未来吗，不清楚)。\u003c/p\u003e\n\u003cp\u003e写日记挺好玩的，我要同步到https://qwqbig.github.io/上hhh\u003c/p\u003e\n\u003cp\u003e欧克，完事了，bye~\u003c/p\u003e\n\u003ch2 id=\"组会报告-2\"\u003e组会报告 2\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e总结：本周主要搞了 K8s 本地环境的网络与镜像难题，完成了从 kubectl 命令式操作到 YAML 声明式管理的思维转变，掌握了 Pod 高级（应该高级吧）模式（Sidecar）、资源隔离（Namespace/Labels）及标准排错流程。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch4 id=\"主要是-k8s-本地环境搭建与-pod-编排\"\u003e主要是 K8s 本地环境搭建与 Pod 编排：\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e1. 可恶的网：Kind + 国内源\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e由于 Minikube 网络受限，转用 Kind (Kubernetes in Docker)。通过配置 GOPROXY 完成源码编译安装，配合 kind-config.yaml 定制国内镜像源及端口映射，解决了环境初始化问题。\u003c/p\u003e","title":"我の组会"},{"content":"\n你好，我是 QwQBiG。\n一名正在计算机科学道路上探索的大一新生。\n我创建这个博客，是为了记录我在学习编程、探索技术世界过程中的思考、笔记和项目实践。我相信，分享是最好的学习方式（有诗也发（或许吧））。\n我的兴趣 C++ 与 STL 算法 玩 openCV Web 开发 （这是myai写的（笑）） Linux 系统 你可以在 GitHub 上找到我。欢迎通过任何方式与我交流！\n","permalink":"https://QwQBiG.github.io/about/","summary":"\u003cp\u003e\u003cimg alt=\"一只可爱的猫（？）\" loading=\"lazy\" src=\"/avatar.png\"\u003e\u003c/p\u003e\n\u003cp\u003e你好，我是 QwQBiG。\u003c/p\u003e\n\u003cp\u003e一名正在计算机科学道路上探索的大一新生。\u003c/p\u003e\n\u003cp\u003e我创建这个博客，是为了记录我在学习编程、探索技术世界过程中的思考、笔记和项目实践。我相信，分享是最好的学习方式（有诗也发（或许吧））。\u003c/p\u003e\n\u003ch3 id=\"我的兴趣\"\u003e我的兴趣\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eC++ 与 STL\u003c/li\u003e\n\u003cli\u003e算法\u003c/li\u003e\n\u003cli\u003e玩 openCV\u003c/li\u003e\n\u003cli\u003eWeb 开发 （这是myai写的（笑））\u003c/li\u003e\n\u003cli\u003eLinux 系统\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e你可以在 \u003ca href=\"https://github.com/QwQBiG\"\u003eGitHub\u003c/a\u003e 上找到我。欢迎通过任何方式与我交流！\u003c/p\u003e","title":"我 是 谁（并非宝可梦）"},{"content":"一直没有写STL内容主要是已经学过了，而且有点懒~\n文章列表 第一篇：STL 容器\n简介：人如其名\n第二篇：STL 算法\n简介：+1\n第三篇：范围for循环\n简介：全面的范围for循环！！！\n","permalink":"https://QwQBiG.github.io/series/cpp/","summary":"\u003cp\u003e一直没有写STL内容主要是已经学过了，而且有点懒~\u003c/p\u003e\n\u003ch2 id=\"文章列表\"\u003e文章列表\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e第一篇：\u003ca href=\"../../posts/stlcontainer/\"\u003eSTL 容器\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e简介：人如其名\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e第二篇：\u003ca href=\"../../posts/stlalgorithm/\"\u003eSTL 算法\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e简介：+1\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e第三篇：\u003ca href=\"../../fanweiforxunhuan/\"\u003e范围for循环\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e简介：全面的范围for循环！！！\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"C++的世界"},{"content":"你好，世界！\n多年之后，看到这些文字，如今的你，是否还会想起，多年前看b站视频打印“hello world!”的那个遥远的下午\u0026hellip;\n如果你能看到这篇文章，那说明我成功了。作为一只冲浪老资历，我一直梦想拥有一个属于自己的、可以记录学习笔记、分享心得的个人博客（东方homo馆）。这便是我的“Hello World”——一个通往更广阔数字世界的起点。（兴许是“读瘾”犯了，要写点东西自己咂摸）\n溯洄从之，道阻且长。如同伊人，此间追寻的过程远比我想象的要曲折，但也比我想象的要收获更多。我遇到了各种各样的问题：从 Docker 的内网穿透失败（其实成功了（但是https）），到 Windows 开发环境的重重陷阱，再到网络连接的神秘莫测，最后到项目结构的频频阻折\u0026hellip;\n所幸“时来天地皆同力”，假借实验室老老资历学长给的焚诀（代理，ai，服务器的一块ubuntu\u0026hellip;）得以为今后的所有故事作一个序。\n而我的感觉是：尽管ai飞速发展，博客、论坛、群聊比比皆是，我自己搜寻资料时，找相应操作时，或者找一些有的没有的奇怪资源时，还是有些力不从心（主要是豆沙包和臭鲸鱼现在确实一般般（25.11））；加上我喜欢鼓捣些长久的、有趣的、有意味（意味深）的东西，顾影自怜，自我怀念，比如写诗著文，都是些艺术形式，于是便有了这个界面的出现。\n谁不想要一个自己的文章网站呢~\n现在，我想把这条被我“踩”出来的、不怕ta“爱而不见”的路，分享给你。\n最终技术栈 内容生成：Hugo (一个快如闪电的静态网站生成器) 免费托管：GitHub Pages (程序员的“免费虚拟主机”) 写作工具：VS Code + Markdown 语法 版本控制与部署：Git 本地环境：Windows 11 第一章：环境搭建——地基决定上层建筑 事实证明，一个干净、稳定、配置正确的本地开发环境，是所有成功的一半。在经历了多次失败后，我总结出以下在 Windows 上最可靠的安装流程。\n1. 安装 Scoop 包管理器 Scoop 是 Windows 上的一个命令行“应用商店”，能让软件安装变得极其简单。\n准备 PowerShell 打开一个普通用户权限的 PowerShell 窗口（不要“以管理员身份运行”），执行以下两条命令：\n1 2 Set-ExecutionPolicy RemoteSigned -Scope CurrentUser irm get.scoop.sh | iex 这里有趣的是如果管理员运行会报错，这是因为Scoop 的 “用户级” 设计哲学，十分不错。\n2. 安装所有核心工具 拥有了 Scoop，我们就可以一键安装所有需要的软件。\n1 2 3 4 5 6 7 8 9 10 11 12 # 安装 Git (版本控制) scoop install git # 安装 Go 语言 (Hugo 模块系统依赖) scoop install go # 安装 Hugo (网站生成器) scoop install hugo # 安装 VS Code (代码编辑器), 需要先添加 \u0026#39;extras\u0026#39; 仓库 scoop bucket add extras scoop install vscode 避坑指南：如果任何一条 scoop install 命令因为网络问题失败 (比如提示\u0026quot;远程方已关闭传输流\u0026quot;)，不要灰心，这是国内网络环境的常见问题。多试几次，或者考虑为 PowerShell 设置临时的网络代理。\n3. 为 Git 配置网络代理 为了确保后续能顺利地从 GitHub 下载主题和推送网站，我们需要为 Git 配置代理（如果你有代理工具的话）。这几乎是一劳永逸地解决网络问题的最佳方案。\n1 2 3 # 将 7890 替换成你自己的代理工具的 HTTP 端口 git config --global http.proxy http://127.0.0.1:7890 git config --global https.proxy https://127.0.0.1:7890 第二章：创建你的博客本体 环境就绪，现在开始盖房子。我选择将项目放在 D 盘，避免 C 盘系统重装带来的麻烦（依旧怕爆红）。\n1. 创建项目骨架 1 2 3 4 5 D: mkdir Projects cd Projects hugo new site my-blog cd my-blog 验证：运行 ls，确保 content、archetypes 等文件夹都已成功创建。\n2. 使用 Hugo Modules 配置主题 我们使用模块化的方式引入 PaperMod 这个简洁优雅的主题。\n1 2 3 4 5 6 # 初始化 git init hugo mod init my-blog # 打开 VS Code 编辑配置文件 code . 在 VS Code 里，清空 hugo.toml 文件，并粘贴以下内容。注意：baseURL 必须换成你自己的 GitHub Pages 网址！\n1 2 3 4 5 6 7 baseURL = \u0026#34;https://QwQBiG.github.io/\u0026#34; # 换成你的！ languageCode = \u0026#34;en-us\u0026#34; title = \u0026#34;QwQBiG\u0026#39;s Blog\u0026#34; # 换成你的博客标题 theme = \u0026#34;github.com/adityatelange/hugo-PaperMod\u0026#34; [params] ShowCodeCopyButtons = true 3. 下载主题 1 hugo mod tidy 这条命令会读取配置文件，并自动下载所需的主题模块。\n第三章：日常写作与发布 这是你以后会日复一日重复的流程。\n1. 创作与预览 1 2 3 4 5 # 创建一篇新文章 hugo new content posts/my-first-post.md # 启动本地实时预览服务器 hugo server 现在，打开浏览器访问 http://localhost:1313。然后去 VS Code 里编辑 content/posts/my-first-post.md 文件（记得把 draft: true 改成 false），你所有的修改都会在浏览器里实时呈现。\n2. 发布到全世界 当你在本地预览满意后，就可以正式发布了。\n第一步：在 GitHub 创建仓库 创建一个公开仓库，名称必须是 你的用户名.github.io。\n第二步：构建并部署 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # (在 my-blog 根目录) 停止本地服务器 (Ctrl+C) # 1. 构建最终的网站文件到 public 文件夹 hugo # 2. 进入 public 文件夹 cd public # 3. 将 public 文件夹作为独立的 Git 仓库推送到线上 git init # 首次部署需要配置用户信息和远程地址 git config --global user.name \u0026#34;你的GitHub用户名\u0026#34; git config --global user.email \u0026#34;你的GitHub注册邮箱\u0026#34; git remote add origin https://github.com/你的用户名/你的用户名.github.io.git # 添加所有文件，提交并强制推送到 main 分支 git add . git commit -m \u0026#34;发布我的第一篇文章！\u0026#34; git branch -M main git push --force -u origin main #最后这一步如果报错可以多试两次，我经常是第二次才成功 避坑指南：整个部署流程最致命的错误，就是把 Git 仓库错误地初始化在了 my-blog 父目录，而不是 public 子目录。一定要确保你是在 public 文件夹里执行 git init 和后续命令！\n3. 最后的等待 GitHub Pages 需要几分钟来部署你的网站。之后，访问 https://你的用户名.github.io，并按下 Ctrl + Shift + R 强制刷新缓存，你就能看到你的成果了。如果其他设备暂时无法访问，请耐心等待 DNS 传播（吃口饭去吧）。\n第四章：重生之我是脚本小子（自动化） 我们每一次的发布还是太繁琐了，那\u0026hellip;就直接写个脚本吧！\n我们可以在项目根目录下创建一个 PowerShell 脚本文件，把所有命令都预先写好。以后，我们只需要运行这个脚本，就能完成所有部署操作。\n注意：我们也可以不用脚本自动化，可以借助GitHub Action实现，我放到了进阶教程里面哈。\n第一步：创建脚本文件 在你的博客项目根目录（my-blog）下，创建一个新文件，命名为 deploy.ps1。\n第二步：填入脚本代码 用 VS Code 打开 deploy.ps1，将以下代码完整地粘贴进去。这是一个纯英文、注释清晰、健壮可靠的版本，能避免所有因编码格式导致的奇怪错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 # ================================================================= # Hugo Deployment Script for GitHub Pages # Author: QwQBiG \u0026amp; hisai # Version: 2.0 (All-English, Robust) # ================================================================= # This script automates the entire process of building and deploying your Hugo site. # It requires one argument: a commit message for this deployment. param( [string]$commitMessage ) # --- Step 1: Validate Input --- if (-not $commitMessage) { Write-Host \u0026#34;ERROR: A commit message is required.\u0026#34; -ForegroundColor Red Write-Host \u0026#34;USAGE: .\\deploy.ps1 \\\u0026#34;Your meaningful commit message\\\u0026#34;\u0026#34; exit 1 } Write-Host \u0026#34;INFO: Starting deployment process...\u0026#34; -ForegroundColor Cyan # --- Step 2: Clean previous build --- Write-Host \u0026#34;INFO: Cleaning up the old \u0026#39;public\u0026#39; directory...\u0026#34; if (Test-Path -Path public) { Remove-Item -Recurse -Force public } # --- Step 3: Build the site with Hugo --- Write-Host \u0026#34;INFO: Building the website with Hugo...\u0026#34; hugo # --- Step 4: Verify the build was successful --- if (-not (Test-Path -Path public)) { Write-Host \u0026#34;ERROR: Hugo build failed. The \u0026#39;public\u0026#39; directory was not created.\u0026#34; -ForegroundColor Red exit 1 } Write-Host \u0026#34;INFO: Hugo build successful.\u0026#34; -ForegroundColor Green # --- Step 5: Navigate into the public directory --- cd public # --- Step 6: Deploy to GitHub --- Write-Host \u0026#34;INFO: Preparing to push to GitHub...\u0026#34; git init git remote add origin https://github.com/QwQBiG/QwQBiG.github.io.git git add . git commit -m \u0026#34;$commitMessage\u0026#34; git branch -M main Write-Host \u0026#34;INFO: Pushing files to the \u0026#39;main\u0026#39; branch...\u0026#34; git push --force -u origin main # --- Step 7: Finalize --- cd .. Write-Host \u0026#34;-----------------------------------------------------\u0026#34; Write-Host \u0026#34;SUCCESS: Deployment complete!\u0026#34; -ForegroundColor Green Write-Host \u0026#34;Your website has been successfully pushed to GitHub.\u0026#34; Write-Host \u0026#34;Please wait 1-2 minutes for GitHub Pages to update.\u0026#34; Write-Host \u0026#34;Then, remember to hard-refresh your browser (Ctrl+Shift+R).\u0026#34; Write-Host \u0026#34;-----------------------------------------------------\u0026#34; 第三步：如何使用 现在，你的发布流程被简化为一条命令：\n1 2 3 4 # 格式: .\\deploy.ps1 \u0026#34;你的发布说明\u0026#34; # 示例: .\\deploy.ps1 \u0026#34;发布我的第二篇文章\u0026#34; 避坑指南：首次运行的准备工作\n出于安全考虑，Windows PowerShell 默认可能不允许运行本地脚本。你需要以管理员身份打开 PowerShell，执行一次性设置：\n1 Set-ExecutionPolicy RemoteSigned 按 Y 确认即可。此后你的电脑就信任并允许运行你自己写的脚本了。\n第五章：主页大一统 1. 问题现象 你可能发现，最新发布的文章会\u0026quot;赤裸裸\u0026quot;地全文显示在主页顶部，没有卡片背景；而旧文章则以带背景的摘要卡片形式排列在下面。同时，你在 hugo.toml 里设置的博客总标题 title 也不见了。\n2. 根本原因 这是 Hugo PaperMod 主题默认的 \u0026ldquo;个人资料模式 (Profile Mode)\u0026rdquo;。它会将最新的一篇文章作为\u0026quot;精选内容\u0026quot;直接在主页展示全文，并隐藏网站总标题，以营造个人主页的氛围。\n但对于一个纯粹的博客，我们更想要一个所有文章样式统一的 \u0026ldquo;列表模式 (List Mode)\u0026rdquo;。\n3. 解决方案：修改 hugo.toml 我们只需要修改配置文件，明确告诉主题我们想要的主页样式。\n第一步：打开 hugo.toml 第二步：替换为推荐配置 将你的 hugo.toml 文件全部内容替换为下面的代码。这份配置不仅解决了布局问题，还额外添加了菜单导航等实用功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # hugo.toml (推荐的完整配置) baseURL = \u0026#34;https://QwQBiG.github.io/\u0026#34; #改成你的！！！ languageCode = \u0026#34;zh-cn\u0026#34; # 修改为中文，对主题更友好 title = \u0026#34;QwQBiG\u0026#39;s Blog\u0026#34; # 这是你的网站总标题 theme = \u0026#34;github.com/adityatelange/hugo-PaperMod\u0026#34; # 主菜单配置 [menu] [[menu.main]] identifier = \u0026#34;archives\u0026#34; name = \u0026#34;归档\u0026#34; url = \u0026#34;/archives/\u0026#34; weight = 10 [[menu.main]] identifier = \u0026#34;tags\u0026#34; name = \u0026#34;标签\u0026#34; url = \u0026#34;/tags/\u0026#34; weight = 20 # 这是最关键的参数配置部分 [params] ShowCodeCopyButtons = true # 1. 关闭特殊的\u0026#34;个人资料\u0026#34;主页模式 # 这会让你的主页变成一个标准的文章列表 [params.profileMode] enabled = false # 2. 在主页文章列表上方显示一个欢迎语 # 这会解决主标题不显示的问题，并让主页更好看 [params.homeInfoParams] Title = \u0026#34;你好，世界 👋\u0026#34; Content = \u0026#34;欢迎来到我的技术博客。在这里记录学习，分享心得。\u0026#34; # 3. 告诉主题，主页的文章列表主要来源于 \u0026#34;posts\u0026#34; 文件夹 mainSections = [\u0026#34;posts\u0026#34;] 第三步：重新部署 保存文件后，用我们全新的自动化脚本发布这次更新！\n1 .\\deploy.ps1 \u0026#34;Update theme settings for a professional homepage layout\u0026#34; 等待部署完成后，强制刷新你的网站。你会看到一个清爽、专业、所有文章样式统一的新主页！\nCongratulations!!!\n进阶内容！！！ 第六章：Giscus - 赋予博客“对话”的能力 静态博客自身无法处理评论，但我们可以嵌入一个基于 GitHub 的、免费且无广告的评论系统：Giscus。\n它的原理绝妙：将你 GitHub 仓库的 Discussions (讨论区) 功能，变成你博客文章的评论区。\n集成 Giscus 的正确步骤 第一步：核心准备 - 找到对的“家”\nGiscus 需要连接到你的博客源代码仓库。在我的实践中，我犯了一个错误，差点连错了地方。\nAha! 时刻：Giscus 需要连接的，就是你存放 hugo.toml 和 content/ 文件夹的那个仓库。对我来说，就是 QwQBiG/QwQBiG.github.io。 调试妙招：如果你不确定仓库的全名，可以在后面“安装 Giscus App”的步骤中，从“Only select repositories (仅选择仓库)”的下拉列表里找到并复制它，绝对不会错！ 第二步：为“家”开启讨论功能\n访问你的博客源代码仓库（例如 https://github.com/QwQBiG/QwQBiG.github.io）。 点击 Settings -\u0026gt; General -\u0026gt; Features。 找到 Discussions，给它打上勾。 第三步：邀请“管家” Giscus App 入住\n访问 Giscus 的应用主页：https://github.com/apps/giscus。 点击 Install，在接下来的页面选择 Only select repositories。 在下拉菜单中，务必勾选你的博客源代码仓库。 点击 Install \u0026amp; Authorize 完成安装。 第四步：在 Giscus 官网生成“门牌号”\n访问 https://giscus.app/。 在“仓库”一栏输入你的仓库全名。现在，因为你已经完成了所有准备，它会立刻成功识别！ 根据页面提示，完成设置（推荐映射关系选择 \u0026ldquo;Discussion title contains page pathname\u0026quot;）。 最后，它会为你生成一段 \u0026lt;script\u0026gt; 代码。复制它。 第五步：把“门牌号”挂到博客上\n在你的 my-blog 项目的 layouts/partials/ 路径下，创建一个新文件 comments.html。 将刚才复制的 \u0026lt;script\u0026gt; 代码完整地粘贴进去。 打开 hugo.toml 文件，在 [params] 的最下方加入代码，正式开启评论功能： 1 2 [params.comments] enabled = true 现在，部署你的网站。你会惊喜地发现，每篇文章下方，都有了一个功能完善的评论区！\n第七章：GitHub Actions - 你的云端部署机器人儿 我们之前做的 deploy.ps1 脚本很好玩，一行命令搞定一切，很有成就感。但它有一个\u0026quot;束缚\u0026rdquo;：它只能在我的电脑上运行。\n而 GitHub Actions，虽然配置文件看起来行数更多，但它提供的是一种更高维度的自动化。是一种 CI/CD（持续集成/持续部署）工具。\n它是什么？ 一个住在你 GitHub 仓库里的免费机器人。你只要把代码 push 到仓库，剩下的所有部署工作，它在云端自动帮你完成。\n它比本地脚本强在哪里？ 随时随地：我可以在平板上、朋友的电脑上、甚至用手机网页版修改一个错字并提交，网站就会自动更新。我不再需要本地的 Hugo 环境和 PowerShell 脚本。 绝对稳定：云端环境是标准化的，永远不会出现\u0026quot;在我电脑上明明是好的\u0026quot;这种问题。 专业流程：这是行业标准，理解它，就等于理解了现代软件开发的核心理念之一：CI/CD（持续集成/持续部署）。 配置 GitHub Actions 的正确步骤 第一步：创建\u0026quot;机器人指令室\u0026quot; 在你的项目根目录，手动创建这样一个文件夹结构：.github/workflows/。\n第二步：编写\u0026quot;机器人指令集\u0026quot; 在 workflows 文件夹里，创建一个 deploy.yml 文件，把下面的\u0026quot;指令集\u0026quot;粘贴进去。\n注意：这份配置是为像我一样，在同一个仓库里进行开发和部署的场景量身定制的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 # .github/workflows/deploy.yml name: Deploy Hugo Site to Pages on: # 当 main 分支有 push 时触发 push: branches: - main jobs: build-and-deploy: runs-on: ubuntu-latest steps: # 第一步：机器人先\u0026#34;检出\u0026#34;你的代码 - name: Checkout uses: actions/checkout@v3 with: submodules: true # 获取主题等子模块 # 第二步：机器人安装 Hugo 环境 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true # 第三步：机器人运行 hugo 命令，构建网站 - name: Build run: hugo # 第四步：机器人将构建好的网站（public目录）部署到 gh-pages 分支 - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: # 这个令牌是 GitHub 自动提供的，无需设置 github_token: ${{ secrets.GITHUB_TOKEN }} # 我们要部署的分支是 gh-pages publish_branch: gh-pages # 部署的源文件夹是 public publish_dir: ./public 第三步：(仅需一次) 设定 GitHub Pages 的发布源 机器人现在会自动把网站发布到 gh-pages 这个分支了。我们需要告诉 GitHub Pages 去这个分支读取网站文件。\n访问你的仓库 Settings -\u0026gt; Pages 在 Build and deployment -\u0026gt; Source 这里，选择 Deploy from a branch 在下面的 Branch 下拉菜单中，选择 gh-pages 分支，然后点击 Save 提示：如果暂时没有 gh-pages 分支，没关系。你先提交一次代码，让机器人运行一次，这个分支就会自动出现，你再回来设置即可。\n总结：全新工作流 现在，你的博客之旅达到了一个全新的境界。\n写作：你只需要专注于在 content/ 文件夹里创建和修改 Markdown 文件 发布：你只需要 git push 就是这样。评论、部署、更新……所有的事情都已自动化。本地的 deploy.ps1 脚本可以光荣退役了（qwq）。\n第一步：在你的电脑上创作 想写新文章了？打开 PowerShell，进入 D:\\Projects\\my-blog 目录。\n运行命令：\n1 hugo new content posts/你的新文章标题.md 在 VS Code 里打开这个新文件，把 draft: false，然后尽情写作。\n第二步：在你的电脑上提交 文章写完并保存后，在 PowerShell 终端里，运行我们最熟悉的三条命令：\n1 2 3 git add . git commit -m \u0026#34;写了一篇关于...的新文章\u0026#34; git push 第三步：其他的一切，交给云端机器人 在你 push 成功的那一刻，你的所有工作就结束了。\n你不需要管 public 文件夹 你不需要管 gh-pages 分支 你不需要运行任何本地脚本 你的 GitHub Actions 机器人会自动被唤醒，在云端帮你完成所有构建和部署的脏活累活。几分钟后，你的新文章就会出现在全世界的面前。\n（Q）反问：登陆、安全和隐私呢？ （A）解答： 这是静态博客和动态博客（比如 WordPress）最大的不同之处，也是它的核心优势。\n登陆： 静态博客没有后台登陆。因为你的网站就是一堆纯粹的 HTML 文件，没有任何数据库或服务器程序在运行。你管理博客的方式，就是修改本地的 Markdown 文件，然后通过 Git 推送。评论区的\u0026quot;登陆\u0026quot;，实际上是授权 Giscus 使用读者的 GitHub 账号，与你的网站本身无关。\n安全： 静态博客极其安全！这是它最爽的地方。黑客们常攻击的是网站的数据库、后台漏洞、服务器程序。而你的网站只是一堆静态文件，没有任何程序可以攻击。黑客无法\u0026quot;黑进\u0026quot;你的网站，因为根本\u0026quot;无门可入\u0026quot;。你的安全由 GitHub 这样的大公司保障，远比自己维护一台服务器要安全得多。\n隐私： 你的网站本身不收集任何访客信息。但你集成的第三方服务（比如 Giscus）有它们自己的隐私策略。这是一个很好的习惯：可以在博客上创建一个\u0026quot;关于\u0026quot;页面或\u0026quot;隐私\u0026quot;页面，简单说明你使用了 Giscus 进行评论，并链接到 GitHub 的隐私政策。\n结语 最后用一句信达雅的名人名言结语：\nTalk is cheap,show me the code.(废话少说，放码过来。) \u0026ndash;Linus Torvalds\n我们可以发现：只要根据报错的代码，一步步走下来，计算机确实就没有什么“黑魔法”，而你就是甘道夫。\nNow,it\u0026rsquo;s your turn.\n","permalink":"https://QwQBiG.github.io/posts/hello-world/","summary":"\u003cp\u003e你好，世界！\u003c/p\u003e\n\u003cp\u003e多年之后，看到这些文字，如今的你，是否还会想起，多年前看b站视频打印“hello world!”的那个遥远的下午\u0026hellip;\u003c/p\u003e\n\u003cp\u003e如果你能看到这篇文章，那说明我成功了。作为一只冲浪老资历，我一直梦想拥有一个属于自己的、可以记录学习笔记、分享心得的个人博客（东方homo馆）。这便是我的“Hello World”——一个通往更广阔数字世界的起点。（兴许是“读瘾”犯了，要写点东西自己咂摸）\u003c/p\u003e\n\u003cp\u003e溯洄从之，道阻且长。如同伊人，此间追寻的过程远比我想象的要曲折，但也比我想象的要收获更多。我遇到了各种各样的问题：从 Docker 的内网穿透失败（其实成功了（但是https）），到 Windows 开发环境的重重陷阱，再到网络连接的神秘莫测，最后到项目结构的频频阻折\u0026hellip;\u003c/p\u003e\n\u003cp\u003e所幸“时来天地皆同力”，假借实验室老老资历学长给的焚诀（代理，ai，服务器的一块ubuntu\u0026hellip;）得以为今后的所有故事作一个序。\u003c/p\u003e\n\u003cp\u003e而我的感觉是：尽管ai飞速发展，博客、论坛、群聊比比皆是，我自己搜寻资料时，找相应操作时，或者找一些有的没有的奇怪资源时，还是有些力不从心（主要是豆沙包和臭鲸鱼现在确实一般般（25.11））；加上我喜欢鼓捣些长久的、有趣的、有意味（意味深）的东西，顾影自怜，自我怀念，比如写诗著文，都是些艺术形式，于是便有了这个界面的出现。\u003c/p\u003e\n\u003cp\u003e谁不想要一个自己的文章网站呢~\u003c/p\u003e\n\u003cp\u003e现在，我想把这条被我“踩”出来的、不怕ta“爱而不见”的路，分享给你。\u003c/p\u003e","title":"史诗级“Hello World”：如何从0到1（划掉）搭建个人技博（技术博客）"}]