<!-- 
  =======================================================================
  PROJECT: NEKO-FALL-ENGINE
  VERSION: 3.9 (Zero Margin / Flush Corner Edition)
  =======================================================================
-->

<style>
  :root {
    /* é»˜è®¤æµ…è‰²æ¨¡å¼å˜é‡ */
    --neko-glass-bg: rgba(255, 255, 255, 0.25);
    --neko-glass-border: rgba(255, 255, 255, 0.5);
    --neko-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
    --neko-text: #555;
    --neko-primary: #ff9a9e;
    --neko-secondary: #fad0c4;
  }

  /* æš—é»‘æ¨¡å¼é€‚é… */
  @media (prefers-color-scheme: dark) {
    :root {
      --neko-glass-bg: rgba(0, 0, 0, 0.4);
      --neko-glass-border: rgba(255, 255, 255, 0.1);
      --neko-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);
      --neko-text: #ddd;
    }
  }
  
  body.dark {
    --neko-glass-bg: rgba(0, 0, 0, 0.4) !important;
    --neko-glass-border: rgba(255, 255, 255, 0.1) !important;
    --neko-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5) !important;
    --neko-text: #ddd !important;
  }

  #neko-engine-root {
    position: fixed;
    /* ã€å…³é”®æ”¹åŠ¨ã€‘å®Œå…¨è´´åˆå·¦ä¸‹è§’ï¼Œä¸ç•™ç©ºéš™ */
    bottom: 0; 
    left: 0;
    
    width: 420px;
    height: 500px;
    z-index: 2147483647;
    pointer-events: none;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    opacity: 0;
    transition: opacity 1s ease;
    user-select: none;
    
    /* ç¼©æ”¾ä¿æŒ 70%ï¼ŒåŸºç‚¹è®¾ä¸ºå·¦ä¸‹è§’ï¼Œç¡®ä¿ç¼©æ”¾åä¾ç„¶è´´è¾¹ */
    transform: scale(0.7); 
    transform-origin: 0% 100%;
  }

  #neko-engine-root.loaded { opacity: 1; }

  #neko-ui-layer {
    position: absolute;
    /* ç¨å¾®è°ƒæ•´æŒ‰é’®ä½ç½®ï¼Œä»¥å…è´´è¾¹å¤ªç´§ä¸å¥½çœ‹ */
    bottom: 120px;
    left: 20px;
    pointer-events: auto;
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .neko-fab {
    width: 56px;
    height: 56px;
    border-radius: 50%;
    background: linear-gradient(135deg, var(--neko-primary) 0%, var(--neko-secondary) 100%);
    box-shadow: 0 4px 15px rgba(255, 105, 135, 0.3);
    border: 2px solid rgba(255,255,255,0.8);
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    backdrop-filter: blur(4px);
  }

  .neko-fab:hover {
    transform: scale(1.1) translateY(-2px);
    box-shadow: 0 8px 25px rgba(255, 105, 135, 0.5);
  }

  .neko-fab svg {
    width: 24px;
    height: 24px;
    fill: white;
    transition: transform 0.3s ease;
  }

  .neko-fab.active::after {
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    border: 2px solid var(--neko-primary);
    animation: ripple 2s infinite;
  }

  .neko-info {
    padding: 8px 16px;
    background: var(--neko-glass-bg);
    border: 1px solid var(--neko-glass-border);
    color: var(--neko-text);
    box-shadow: var(--neko-shadow);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border-radius: 20px;
    font-size: 12px;
    font-weight: 600;
    letter-spacing: 0.5px;
    transform: translateX(-10px);
    opacity: 0;
    transition: all 0.3s ease;
    white-space: nowrap; 
  }

  #neko-ui-layer:hover .neko-info {
    transform: translateX(0);
    opacity: 1;
  }

  @keyframes ripple {
    0% { transform: scale(1); opacity: 0.8; }
    100% { transform: scale(1.6); opacity: 0; }
  }

  canvas { display: block; width: 100%; height: 100%; }
</style>

<div id="neko-engine-root">
  <audio id="neko-audio" loop crossorigin="anonymous">
    <!-- ğŸ‘‡ ä½ çš„éŸ³ä¹é“¾æ¥ ğŸ‘‡ -->
    <source src="/music/oblivious.mp3" type="audio/mpeg">
  </audio>

  <div id="neko-ui-layer">
    <div class="neko-fab" id="neko-toggle-btn">
      <svg id="icon-play" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
      <svg id="icon-pause" viewBox="0 0 24 24" style="display:none; transform: scale(0.9);"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
    </div>
    <div class="neko-info">Loading...</div>
  </div>

  <canvas id="neko-canvas"></canvas>
</div>

<script>
/**
 * ğŸ± NEKO ENGINE v3.9
 * Updates: Zero Margin (Flush Left-Bottom)
 */

const CONFIG = {
  musicTitle: "é›¯åå¦²æ­Œå",
  
  gravity: 0.038,
  airResistance: 0.998,
  bounceDamping: 0.6,
  softBodyStiffness: 0.08,
  
  colors: {
    whiteCat:  { base: '#fdfbf7', shadow: '#e6e2d6', blush: '#ffcdd2' },
    orangeCat: { base: '#f8d29d', shadow: '#e0b075', blush: '#ff8a80', pattern: '#e6a23c' },
    greyCat:   { base: '#d1d5db', shadow: '#9ca3af', blush: '#fca5a5' },
    calicoCat: { base: '#fff', shadow: '#ddd', pattern1: '#333', pattern2: '#f6ad55' }
  },
  
  bpm: 80,
  
  keyHeights: { white: 100, black: 65 }
};

const Utils = {
  random: (min, max) => Math.random() * (max - min) + min,
  drawRoundRect: (ctx, x, y, w, h, r) => {
    if (w < 2 * r) r = w / 2;
    if (h < 2 * r) r = h / 2;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }
};

class NoteParticle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.vx = Utils.random(-1.5, 1.5);
    this.vy = Utils.random(-3, -1);
    this.rotation = Utils.random(-0.5, 0.5);
    this.rotSpeed = Utils.random(-0.05, 0.05);
    this.scale = 0;
    this.targetScale = Utils.random(0.6, 1.0);
    this.life = 1.0;
    this.decay = 0.015;
    this.type = Math.random() > 0.5 ? 'single' : 'double';
    this.color = `hsl(${Utils.random(200, 340)}, 80%, 65%)`;
  }
  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.05;
    this.rotation += this.rotSpeed;
    this.life -= this.decay;
    if (this.scale < this.targetScale) this.scale += (this.targetScale - this.scale) * 0.2;
  }
  draw(ctx) {
    if (this.life <= 0) return;
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation);
    ctx.scale(this.scale, this.scale);
    ctx.globalAlpha = this.life;
    ctx.fillStyle = this.color;
    ctx.strokeStyle = this.color;
    ctx.lineWidth = 2;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    ctx.beginPath();
    if (this.type === 'single') {
      ctx.ellipse(-4, 6, 4, 3, -0.2, 0, Math.PI * 2); 
      ctx.fill();
      ctx.beginPath(); ctx.moveTo(-1, 6); ctx.lineTo(-1, -10); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(-1, -10); ctx.bezierCurveTo(4, -6, 8, -4, 6, 2); ctx.stroke();
    } else {
      ctx.beginPath(); ctx.ellipse(-6, 6, 3.5, 2.5, -0.2, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(6, 4, 3.5, 2.5, -0.2, 0, Math.PI*2); ctx.fill();
      ctx.beginPath();
      ctx.moveTo(-3, 6); ctx.lineTo(-3, -8);
      ctx.moveTo(9, 4); ctx.lineTo(9, -10);
      ctx.stroke();
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(-3, -8); ctx.bezierCurveTo(3, -7, 6, -9, 9, -10); ctx.stroke();
    }
    ctx.restore();
  }
}

class Particle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.vx = Utils.random(-1, 1);
    this.vy = Utils.random(-1.5, -0.2);
    this.life = 1.0;
    this.decay = Utils.random(0.008, 0.015);
    this.size = Utils.random(3, 5);
    this.color = `hsl(${Utils.random(30, 60)}, 100%, 75%)`;
    this.rotation = Math.random() * Math.PI;
  }
  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.03; 
    this.life -= this.decay;
    this.rotation += 0.05;
  }
  draw(ctx) {
    if (this.life <= 0) return;
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation);
    ctx.globalAlpha = this.life;
    ctx.fillStyle = this.color;
    ctx.beginPath();
    for (let i = 0; i < 4; i++) {
      ctx.lineTo(Math.cos(i * Math.PI / 2) * this.size, Math.sin(i * Math.PI / 2) * this.size);
      ctx.lineTo(Math.cos((i * Math.PI / 2) + Math.PI / 4) * (this.size * 0.4), Math.sin((i * Math.PI / 2) + Math.PI / 4) * (this.size * 0.4));
    }
    ctx.fill();
    ctx.restore();
  }
}

class PianoKey {
  constructor(index, x, w, h, isBlack) {
    this.index = index;
    this.x = x;
    this.y = 0;
    this.w = w;
    this.h = h;
    this.isBlack = isBlack;
    this.pressOffset = 0;
    this.targetOffset = 0;
  }
  update() {
    this.pressOffset += (this.targetOffset - this.pressOffset) * 0.1;
    if (Math.abs(this.targetOffset - this.pressOffset) < 0.5 && this.targetOffset > 0) {
      this.targetOffset = 0;
    }
  }
  hit() {
    this.targetOffset = 20; 
  }
  draw(ctx, baseY) {
    const drawX = this.x;
    const drawY = baseY - this.h + this.pressOffset;
    ctx.shadowColor = 'rgba(0,0,0,0.1)';
    ctx.shadowBlur = 10;
    ctx.shadowOffsetY = 4;
    
    const grad = ctx.createLinearGradient(drawX, drawY, drawX, drawY + this.h);
    if (this.isBlack) {
      grad.addColorStop(0, '#434343');
      grad.addColorStop(1, '#000000');
      ctx.fillStyle = grad;
      Utils.drawRoundRect(ctx, drawX, drawY, this.w, this.h, 3);
      ctx.fill();
      ctx.fillStyle = 'rgba(255,255,255,0.15)';
      ctx.fillRect(drawX + 4, drawY + 5, this.w - 8, this.h - 10);
    } else {
      grad.addColorStop(0, '#ffffff');
      grad.addColorStop(1, '#f0f0f0');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.roundRect(drawX, drawY, this.w, this.h, [0, 0, 4, 4]);
      ctx.fill();
      ctx.fillStyle = '#ddd';
      ctx.fillRect(drawX, drawY + this.h - 10, this.w, 10);
    }
    ctx.shadowColor = 'transparent';
  }
}

class KawaiiCat {
  constructor(canvasWidth) {
    this.radius = 24;
    this.x = Utils.random(this.radius + 20, canvasWidth - this.radius - 20);
    this.y = -60;
    this.vx = 0;
    this.vy = Utils.random(0.05, 0.3); 
    this.rotation = Utils.random(-0.1, 0.1);
    this.rotVelocity = 0;
    this.scaleX = 1;
    this.scaleY = 1;
    this.type = Math.floor(Math.random() * 4);
    this.expression = 'IDLE';
    this.dead = false;
  }
  
  update(gravity, airRes, height, keys) {
    this.vy += gravity;
    this.vx *= airRes;
    this.y += this.vy;
    this.x += this.vx;
    this.rotation += this.rotVelocity;
    this.scaleX += (1 - this.scaleX) * CONFIG.softBodyStiffness;
    this.scaleY += (1 - this.scaleY) * CONFIG.softBodyStiffness;
    
    let groundLevel = height - CONFIG.keyHeights.white;
    let targetKey = null;

    for (let k of keys) {
        if (k.isBlack && this.x >= k.x && this.x <= k.x + k.w) {
            groundLevel = height - CONFIG.keyHeights.black;
            targetKey = k;
            break; 
        }
    }

    if (!targetKey) {
        const keyWidth = 420 / 7; 
        const keyIdx = Math.floor(this.x / keyWidth);
        if (keys[keyIdx]) {
            targetKey = keys[keyIdx];
        }
    }

    if (this.y + this.radius >= groundLevel && this.vy > 0 && this.expression !== 'HAPPY') {
        if (targetKey) targetKey.hit();
        
        this.vy = -Math.abs(this.vy * CONFIG.bounceDamping) - 2.5; 
        this.vx = Utils.random(-1.2, 1.2); 
        this.rotVelocity = Utils.random(-0.03, 0.03);
        this.scaleX = 1.4; 
        this.scaleY = 0.6;
        this.expression = 'SHOCK';
        setTimeout(() => { if(!this.dead) this.expression = 'HAPPY'; }, 300);
        
        this.y = groundLevel - this.radius;
        return { hit: true, x: this.x, y: groundLevel };
    }
    
    if (this.y > height + 100) this.dead = true;
    return null;
  }
  
  draw(ctx) {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation);
    ctx.scale(this.scaleX, this.scaleY);
    
    let colors = CONFIG.colors.whiteCat;
    if (this.type === 1) colors = CONFIG.colors.calicoCat;
    if (this.type === 2) colors = CONFIG.colors.orangeCat;
    if (this.type === 3) colors = CONFIG.colors.greyCat;
    
    ctx.fillStyle = colors.base;
    ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = colors.shadow;
    ctx.beginPath(); ctx.arc(0, 8, this.radius - 2, 0.2 * Math.PI, 0.8 * Math.PI); ctx.fill();
    
    ctx.fillStyle = colors.base;
    ctx.beginPath(); ctx.moveTo(-18, -10); ctx.quadraticCurveTo(-28, -28, -10, -20); ctx.fill();
    ctx.beginPath(); ctx.moveTo(18, -10); ctx.quadraticCurveTo(28, -28, 10, -20); ctx.fill();
    ctx.fillStyle = colors.blush;
    ctx.beginPath(); ctx.moveTo(-18, -10); ctx.quadraticCurveTo(-24, -22, -12, -18); ctx.fill();
    ctx.beginPath(); ctx.moveTo(18, -10); ctx.quadraticCurveTo(24, -22, 12, -18); ctx.fill();

    if (this.type === 1) {
      ctx.fillStyle = colors.pattern1;
      ctx.beginPath(); ctx.arc(-10, -10, 8, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = colors.pattern2;
      ctx.beginPath(); ctx.arc(12, -8, 6, 0, Math.PI*2); ctx.fill();
    }
    if (this.type === 2) {
       ctx.strokeStyle = colors.pattern;
       ctx.lineWidth = 2;
       ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(0, -10); ctx.stroke();
       ctx.beginPath(); ctx.moveTo(-6, -18); ctx.lineTo(-6, -12); ctx.stroke();
       ctx.beginPath(); ctx.moveTo(6, -18); ctx.lineTo(6, -12); ctx.stroke();
    }

    ctx.strokeStyle = '#3e3e3e';
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    
    if (this.expression === 'IDLE') {
      ctx.fillStyle = '#3e3e3e';
      ctx.beginPath(); ctx.arc(-8, 0, 2.5, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(8, 0, 2.5, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.moveTo(-4, 6); ctx.quadraticCurveTo(0, 8, 4, 6); ctx.stroke();
    } else if (this.expression === 'SHOCK') {
      ctx.beginPath();
      ctx.moveTo(-12, -2); ctx.lineTo(-6, 2); ctx.lineTo(-12, 6);
      ctx.moveTo(12, -2); ctx.lineTo(6, 2); ctx.lineTo(12, 6);
      ctx.stroke();
      ctx.beginPath(); ctx.arc(0, 8, 3, 0, Math.PI*2); ctx.strokeStyle='#3e3e3e'; ctx.stroke();
    } else if (this.expression === 'HAPPY') {
      ctx.beginPath();
      ctx.moveTo(-12, 2); ctx.quadraticCurveTo(-8, -2, -4, 2);
      ctx.moveTo(4, 2); ctx.quadraticCurveTo(8, -2, 12, 2);
      ctx.moveTo(-4, 6); ctx.quadraticCurveTo(0, 8, 4, 6); 
      ctx.stroke(); 
      ctx.fillStyle = colors.blush;
      ctx.globalAlpha = 0.6;
      ctx.beginPath(); ctx.arc(-14, 6, 4, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(14, 6, 4, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
      ctx.beginPath();
    }
    ctx.restore();
  }
}

class NekoEngine {
  constructor() {
    this.root = document.getElementById('neko-engine-root');
    document.body.appendChild(this.root);

    this.canvas = document.getElementById('neko-canvas');
    this.ctx = this.canvas.getContext('2d');
    this.audio = document.getElementById('neko-audio');
    this.uiBtn = document.getElementById('neko-toggle-btn');
    this.uiInfo = document.querySelector('.neko-info');
    
    this.width = 420;
    this.height = 500;
    this.isPlaying = false;
    this.lastTime = 0;
    this.keys = [];
    this.cats = [];
    this.particles = [];
    this.beatTimer = 0;
    this.nextBeat = 0;
    this.init();
  }
  
  init() {
    this.resize();
    window.addEventListener('resize', () => this.resize());
    
    this.uiInfo.innerText = "Ready: " + CONFIG.musicTitle;

    const whiteCount = 7;
    const whiteW = this.width / whiteCount;
    const blackW = whiteW * 0.65;
    const whiteH = CONFIG.keyHeights.white;
    const blackH = CONFIG.keyHeights.black;
    
    for (let i = 0; i < whiteCount; i++) {
      this.keys.push(new PianoKey(i, i * whiteW, whiteW, whiteH, false));
    }
    const blackIndices = [0, 1, 3, 4, 5]; 
    blackIndices.forEach(i => {
      this.keys.push(new PianoKey(100+i, (i + 1) * whiteW - blackW/2, blackW, blackH, true));
    });
    
    this.uiBtn.addEventListener('click', () => this.toggleState());
    setTimeout(() => this.root.classList.add('loaded'), 500);
    requestAnimationFrame((t) => this.loop(t));
  }
  
  resize() {
    const dpr = window.devicePixelRatio || 1;
    this.width = 420; 
    this.height = 500;
    this.canvas.width = this.width * dpr;
    this.canvas.height = this.height * dpr;
    this.ctx.scale(dpr, dpr);
  }
  
  toggleState() {
    if (this.isPlaying) {
      this.audio.pause();
      this.isPlaying = false;
      this.uiBtn.classList.remove('active');
      this.uiInfo.innerText = "Music Paused";
      document.getElementById('icon-play').style.display = 'block';
      document.getElementById('icon-pause').style.display = 'none';
    } else {
      this.audio.play().catch(e => console.log("Autoplay blocked", e));
      this.isPlaying = true;
      this.uiBtn.classList.add('active');
      this.uiInfo.innerText = "Playing Â· " + CONFIG.musicTitle;
      document.getElementById('icon-play').style.display = 'none';
      document.getElementById('icon-pause').style.display = 'block';
    }
  }
  
  spawnCat() {
    this.cats.push(new KawaiiCat(this.width));
  }
  
  spawnParticles(x, y) {
    for(let i=0; i<4; i++) this.particles.push(new Particle(x, y));
    const noteCount = Math.floor(Math.random() * 2) + 1;
    for(let i=0; i<noteCount; i++) this.particles.push(new NoteParticle(x, y));
  }
  
  loop(timestamp) {
    const dt = timestamp - this.lastTime;
    this.lastTime = timestamp;
    this.ctx.clearRect(0, 0, this.width, this.height);
    
    if (this.isPlaying) {
      this.beatTimer += dt;
      if (this.beatTimer >= this.nextBeat) {
        this.spawnCat();
        const beatDuration = 60000 / CONFIG.bpm; 
        const multiplier = Math.random() > 0.7 ? 0.5 : 1;
        this.nextBeat = beatDuration * multiplier * (1 + Utils.random(-0.1, 0.1));
        this.beatTimer = 0;
      }
    }
    
    const pianoY = this.height - CONFIG.keyHeights.white;
    this.ctx.fillStyle = '#6d1b1b';
    this.ctx.fillRect(0, pianoY - 5, this.width, 5);
    
    const whiteKeys = this.keys.filter(k => !k.isBlack);
    const blackKeys = this.keys.filter(k => k.isBlack);
    
    whiteKeys.forEach(k => { k.update(); k.draw(this.ctx, this.height); });
    blackKeys.forEach(k => { k.update(); k.draw(this.ctx, this.height); });
    
    for (let i = this.cats.length - 1; i >= 0; i--) {
      const cat = this.cats[i];
      const collision = cat.update(CONFIG.gravity, CONFIG.airResistance, this.height, this.keys);
      if (collision && collision.hit) {
        this.spawnParticles(collision.x, collision.y);
      }
      cat.draw(this.ctx);
      if (cat.dead) this.cats.splice(i, 1);
    }
    
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const p = this.particles[i];
      p.update();
      p.draw(this.ctx);
      if (p.life <= 0) this.particles.splice(i, 1);
    }
    
    requestAnimationFrame((t) => this.loop(t));
  }
}

window.addEventListener('load', () => {
  new NekoEngine();
});
</script>